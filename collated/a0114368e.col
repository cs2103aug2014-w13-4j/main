//@author: a0114368e



	/**
	 * origin: src\common\Feedback.java
	 */


/**
 * This class is used to update the display in GUI following the action by the
 * user. It contains the feedback message that will be shown in the notification
 * pane, the task list that is shown in the table view, and the individual task
 * that is shown in the task display.
 */
public class Feedback {

    private String feedbackMessage;
    private ArrayList<Task> taskList;
    private Task taskDisplay;

    public Feedback(String message, ArrayList<Task> tasks, Task task) {
        setFeedbackMessage(message);
        setTaskList(tasks);
        setTaskDisplay(task);
    }

    public ArrayList<Task> getTaskList() {
        return taskList;
    }

    public void setTaskList(ArrayList<Task> taskList) {
        this.taskList = taskList;
    }

    public String getFeedbackMessage() {
        return feedbackMessage;
    }

    public void setFeedbackMessage(String feedbackMessage) {
        this.feedbackMessage = feedbackMessage;
    }

    public Task getTaskDisplay() {
        return taskDisplay;
    }

    public void setTaskDisplay(Task taskDisplay) {
        this.taskDisplay = taskDisplay;
    }
}

	// End of segment: src\common\Feedback.java





	/**
	 * origin: src\common\History.java
	 */


/**
 * This class is used for undoing actions. It stores the command enum of the
 * previous command taken, and the tasks that needs to be written to storage to
 * undo it
 * */
public class History {
    private CommandEnum command;
    private ArrayList<Task> tasks;

    public History(CommandEnum command, ArrayList<Task> tasks) {
        setCommand(command);
        setTasks(tasks);
    }

    public CommandEnum getCommand() {
        return command;
    }

    public void setCommand(CommandEnum command) {
        this.command = command;
    }

    public ArrayList<Task> getTasks() {
        return tasks;
    }

    public void setTasks(ArrayList<Task> tasks) {
        this.tasks = tasks;
    }
}

	// End of segment: src\common\History.java





	/**
	 * origin: src\common\MessageCreator.java
	 */


/**
 * Creates the message given the variable text.
 */
public class MessageCreator {

    public static String createMessage(String message, String variableText1,
            String variableText2) {
        return String.format(message, variableText1, variableText2);
    }

}

	// End of segment: src\common\MessageCreator.java





	/**
	 * origin: src\common\PriorityLevelEnum.java
	 */


/**
 * This is the enum class for the priority level. There are currently 4
 * different levels (default, green, orange and red). The user can indicate the
 * priority level by number, name, or the first letter of the name of the level.
 *
 */
public enum PriorityLevelEnum {
    DEFAULT(0, "default"), GREEN(1, "green"), ORANGE(2, "orange"), RED(3, "red");

    private static final int FIRST_INDEX = 0;

    private final int level;

    private final String name;

    PriorityLevelEnum(int level, String name) {
        this.level = level;
        this.name = name;
    }

    public int getLevel() {
        return level;
    }

    public String getName() {
        return name;
    }

    public String getShortForm() {
        return String.valueOf(name.charAt(FIRST_INDEX));
    }

    /**
     * Returns the corresponding priority level Enum given the integer level.
     *
     * @param level
     *            : the priority level
     * @return: priority level Enum
     * @throws InvalidPriorityLevelException
     */
    public static PriorityLevelEnum fromInteger(int level)
            throws InvalidPriorityLevelException {
        return findPriorityLevelFromLevel(level);
    }

    /**
     * Returns the corresponding priority level Enum given the string name.
     *
     * @param name
     *            : the name of the priority level
     * @return: priority level Enum
     * @throws InvalidPriorityLevelException
     */
    public static PriorityLevelEnum fromString(String name)
            throws InvalidPriorityLevelException {
        name.toLowerCase().trim();
        return findPriorityLevelFromName(name);
    }

    private static PriorityLevelEnum findPriorityLevelFromLevel(int level)
            throws InvalidPriorityLevelException {
        for (PriorityLevelEnum e : PriorityLevelEnum.values()) {
            if (level == e.getLevel()) {
                return e;
            }
        }
        throw new InvalidPriorityLevelException();
    }

    private static PriorityLevelEnum findPriorityLevelFromName(String nameString)
            throws InvalidPriorityLevelException {
        String name = nameString.toLowerCase().trim();
        for (PriorityLevelEnum e : PriorityLevelEnum.values()) {
            if (name.equals(e.getName()) || name.equals(e.getShortForm())) {
                return e;
            }
        }
        throw new InvalidPriorityLevelException();
    }
}

	// End of segment: src\common\PriorityLevelEnum.java





	/**
	 * origin: src\common\Task.java
	 */

/**
 * This class stores all the attributes of a task. Currently, 4 types of tasks
 * are supported: Deadline Task, Floating Task, Timed Task and Conditional Task
 *
 */
public class Task implements Comparable<Task> {
    public static final int ID_FOR_NEW_TASK = 0;
    private int id = 0;
    private String name = "";
    private Calendar dateDue = null;
    private Calendar dateStart = null;
    private Calendar dateEnd = null;
    private PriorityLevelEnum priorityLevel = PriorityLevelEnum.DEFAULT;
    private String note = "";
    private ArrayList<String> tags = new ArrayList<String>();
    private ArrayList<StartEndDatePair> conditionalDates = new ArrayList<StartEndDatePair>();
    private boolean isDeleted = false;

    public Task() {
    }

    public void addTags(ArrayList<String> newTags) {
        newTags.removeAll(tags);
        tags.addAll(newTags);
    }

    public void appendConditionalDates(
            ArrayList<StartEndDatePair> conditionalDates) {
        this.conditionalDates.addAll(conditionalDates);
    }

    public ArrayList<StartEndDatePair> getConditionalDates() {
        return conditionalDates;
    }

    public Calendar getDateDue() {
        return dateDue;
    }

    public Calendar getDateEnd() {
        return dateEnd;
    }

    public Calendar getDateStart() {
        return dateStart;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getNote() {
        return note;
    }

    public PriorityLevelEnum getPriorityLevel() {
        return priorityLevel;
    }

    public Integer getPriorityLevelInteger() {
        if (priorityLevel == null) {
            return null;
        } else {
            return priorityLevel.getLevel();
        }
    }

    public ArrayList<String> getTags() {
        return tags;
    }

    public boolean isCompleted() {
        Boolean isTimedTaskCompleted = isTimedTask() && isDateEndOver();
        Boolean isDeadlineTaskCompleted = isDeadlineTask() && dateEnd != null;
        Boolean isFloatingTaskCompleted = isFloatingTask() && dateEnd != null;
        return isTimedTaskCompleted || isDeadlineTaskCompleted
                || isFloatingTaskCompleted;
    }

    public boolean isConditionalTask() {
        return dateDue == null && dateStart == null && dateEnd == null
                && !conditionalDates.isEmpty();
    }

    public boolean isConfirmed() {
        if (conditionalDates != null && !conditionalDates.isEmpty()) {
            return (dateStart != null || dateEnd != null);
        } else {
            return true;
        }
    }

    private boolean isDateEndOver() {
        return dateEnd.compareTo(Calendar.getInstance()) <= 0;
    }

    public boolean isDeadlineTask() {
        return dateDue != null && dateStart == null
                && conditionalDates.isEmpty();
    }

    public boolean isDeleted() {
        return isDeleted;
    }

    public boolean isFloatingTask() {
        return dateDue == null && dateStart == null
                && conditionalDates.isEmpty();
    }

    public boolean isTimedTask() {
        return dateDue == null && dateStart != null && dateEnd != null;
    }

    public void setConditionalDates(ArrayList<StartEndDatePair> conditionalDates) {
        this.conditionalDates = conditionalDates;
    }

    public void setDateDue(Calendar dateDue) {
        this.dateDue = dateDue;
    }

    public void setDateEnd(Calendar dateEnd) {
        this.dateEnd = dateEnd;
    }

    public void setDateStart(Calendar dateStart) {
        this.dateStart = dateStart;
    }

    public void setDeleted(boolean isDeleted) {
        this.isDeleted = isDeleted;
    }

    public void setId(int id) {
        this.id = id;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setNote(String note) {
        this.note = note;
    }

    public void setPriorityLevel(PriorityLevelEnum priorityLevel) {
        this.priorityLevel = priorityLevel;
    }

    public void setStartDueDateFromConditional(int id) {
        assert (conditionalDates != null && id >= conditionalDates.size());
        dateStart = conditionalDates.get(id - 1).getStartDate();
        dateEnd = conditionalDates.get(id - 1).getEndDate();
    }

    public void setTags(ArrayList<String> tags) {
        this.tags = tags;
    }

    @Override
    public int compareTo(Task otherTask) {
        Calendar firstDate = this.getDateForComparison();
        Calendar secondDate = otherTask.getDateForComparison();
        if (firstDate == null && secondDate == null) {
            return 0;
        } else if (firstDate == null) {
            return 1;
        } else if (secondDate == null) {
            return -1;
        } else {
            return (firstDate.compareTo(secondDate));
        }
    }

    public Calendar getDateForComparison() {
        if (isDeadlineTask()) {
            return getDateDue();
        } else if (isTimedTask()) {
            return getDateStart();
        } else {
            return null;
        }
    }
}

	// End of segment: src\common\Task.java





	/**
	 * origin: src\logic\Logic.java
	 */


/**
 * This class provides the respective methods to execute the different commands
 * as specified by the user. It also interacts with storage to retrieve the
 * task, or to write the task back to storage
 *
 */
public class Logic {

    private static final int NEXT = 1;
    private static final int HOURS_TO_SECONDS = 3600;
    private static final String ERROR_SUGGEST_MESSAGE = "Start and end date and duration are required";
    private static final int MAX_INVALID_DURATION = 0;

    /**
     * This constructor follows the singleton pattern It can only be called with
     * in the current class (Logic.getInstance()) This is to ensure that only
     * there is exactly one instance of Logic class
     *
     * @return an object instance of the Logic class.
     * @throws IOException
     * @throws FileFormatNotSupportedException
     */
    public static Logic getInstance() throws IOException,
            FileFormatNotSupportedException {
        if (instance == null) {
            instance = new Logic();
            ApplicationLogger.getLogger()
                    .log(Level.INFO, "Initializing Logic.");
            instance.storage = StorageApi.getInstance();
        }
        return instance;
    }

    /**
     * Always creates a new instance of the Logic class. For debugging purposes.
     *
     * @return an object instance of the Logic class.
     * @throws IOException
     * @throws FileFormatNotSupportedException
     */
    public static Logic getNewInstance() throws IOException,
            FileFormatNotSupportedException {
        instance = new Logic();
        ApplicationLogger.getLogger().log(Level.INFO, "Initializing Logic.");
        instance.storage = StorageApi.getNewInstance();
        return instance;
    }

    private static final String LOG_TIMED_TASK = "Adding timed task.";
    private static final String LOG_DEADLINE_TASK = "Adding deadline task.";
    private static final String LOG_CONDITIONAL_TASK = "Adding conditional task.";
    private static final String LOG_FLOATING_TASK = "Adding floating task.";
    private static final String COMPLETED_KEYWORD = "completed";
    private static final String ALL_KEYWORD = "all";
    private static final String ACTIVE_KEYWORD = "active";
    private static final String ERROR_UNDO_MESSAGE = "Search and display actions cannot be undone.";
    private static final String INVALID_TASK_ID_MESSAGE = "Task ID: %1$s is invalid!";
    private static final String INVALID_DATE_ID_MESSAGE = "Date ID: %1$s is invalid!";
    private static final String ERROR_UPDATE_CONDITIONAL_TASK_MESSAGE = "Task %1$s is a conditional task, so it should contain multiple start and end dates";
    private static final String ERROR_COMPLETE_MESSAGE = "Only uncompleted deadline tasks can be completed";
    private static final String ERROR_DATE_INPUT_MESSAGE = "The date parameters provided are invalid.";
    private static final String ERROR_CLEAR_MESSAGE = "The given parameters for clear are invalid.";
    private static final String ERROR_DISPLAY_MESSAGE = "The display keyword: %1$s is invalid.";
    private static final String ADD_MESSAGE = "%1$s is successfully added.";
    private static final String DELETE_MESSAGE = "%1$s is successfully deleted";
    private static final String EDIT_MESSAGE = "%1$s is successfully edited.";
    private static final String COMPLETE_MESSAGE = "%1$s is marked as completed.";
    private static final String SEARCH_MESSAGE = "%1$s results are found.";
    private static final String DISPLAY_MESSAGE = "All %1$s tasks are displayed.";
    private static final String DISPLAY_TASK_MESSAGE = "Task %1$s: %2$s is displayed.";
    private static final String ERROR_ALREADY_DELETED_MESSAGE = "Task %1$s is already deleted.";
    private static final String CONFIRM_MESSAGE = "%1$s is marked as confirmed.";
    private static final String UNDO_MESSAGE = "%1$s %2$s is undone";
    private static final String UNDO_CLEAR_MESSAGE = "Clear is undone";
    private static final String CLEAR_MESSAGE = "All completed task are cleared from the list";
    private static final String SUGGESTION_MESSAGE = "We have some suggestions for you";
    private static final String NO_SUGGESTION_MESSAGE = "Sorry, we couldn't find a good slot for you";
    // Represent a thirty minutes block in milliseconds
    private static long TIME_BLOCK = 1800000;
    private static long HOUR_TO_MILLIS = 3600000;
    private static int MAX_RESULT = 3;
    private static int START_VALUE = 0;
    StorageApi storage = null;

    private LogicUndo logicUndo = new LogicUndo();

    private Cloner cloner = new Cloner();
    private ArrayList<Task> suggestions = new ArrayList<Task>();

    private static Logic instance = null;

    private Logic() {
    }

    /**
     * Accept a suggested date
     *
     * @return Feedback containing the updated list of tasks
     * @throws InvalidInputException
     * @throws TaskNotFoundException
     * @throws IOException
     * @throws InvalidCommandUseException
     * @throws TimeIntervalOverlapException
     */
    Feedback accept(Hashtable<ParamEnum, ArrayList<String>> param)
            throws InvalidInputException, TaskNotFoundException, IOException,
            InvalidCommandUseException, TimeIntervalOverlapException {
        int taskId = getTaskId(param);
        Task task = getTaskFromSuggestion(taskId-1);
        String name = task.getName();
        TaskModifier.resetId(task);
        storage.writeTaskToFile(task);
        Task clonedTask = cloner.deepClone(task);
        logicUndo.pushAcceptCommandToHistory(clonedTask);
        ArrayList<Task> taskList = storage.getAllActiveTasks();
        suggestions.clear();
        return createTaskListFeedback(
                MessageCreator.createMessage(ADD_MESSAGE, name, null), taskList);
    }

    /**
     * Adds a new task to the file
     *
     * @param param
     *            : the command created by commandParser
     * @return feedback containing the updated list of tasks in the file, and
     *         the message.
     * @throws TaskNotFoundException
     * @throws IOException
     * @throws InvalidDateFormatException
     * @throws InvalidInputException
     * @throws TimeIntervalOverlapException
     */
    Feedback add(Hashtable<ParamEnum, ArrayList<String>> param)
            throws TaskNotFoundException, IOException,
            InvalidDateFormatException, InvalidInputException,
            TimeIntervalOverlapException {
        Task task = new Task();
        if (hasFloatingTaskParams(param)) {
            ApplicationLogger.getLogger().log(Level.INFO, LOG_FLOATING_TASK);
            TaskModifier.modifyFloatingTask(param, task);
        } else if (hasConditionalTaskParams(param)) {
            ApplicationLogger.getLogger().log(Level.INFO, LOG_CONDITIONAL_TASK);
            TaskModifier.modifyConditionalTask(param, task);
        } else if (hasTimedTaskParams(param)) {
            ApplicationLogger.getLogger().log(Level.INFO, LOG_TIMED_TASK);
            TaskModifier.modifyTimedTask(param, task);
        } else if (hasDeadlineTaskParams(param)) {
            ApplicationLogger.getLogger().log(Level.INFO, LOG_DEADLINE_TASK);
            TaskModifier.modifyDeadlineTask(param, task);
        } else {
            throw new InvalidInputException(ERROR_DATE_INPUT_MESSAGE);
        }
        storage.writeTaskToFile(task);
        String name = task.getName();
        Task clonedTask = cloner.deepClone(task);
        logicUndo.pushAddCommandToHistory(clonedTask);
        ArrayList<Task> taskList = storage.getAllActiveTasks();
        return createTaskAndTaskListFeedback(
                MessageCreator.createMessage(ADD_MESSAGE, name, null),
                taskList, task);
    }

    /**
     * Clear all the completed task in the task list
     *
     * @param param
     *            : the command created by commandParser
     * @return feedback containing the list of tasks that are not completed in
     *         the file, and the message.
     * @throws TaskNotFoundException
     * @throws IOException
     * @throws InvalidInputException
     * @throws TimeIntervalOverlapException
     */
    Feedback clear(Hashtable<ParamEnum, ArrayList<String>> param)
            throws TaskNotFoundException, IOException, InvalidInputException,
            TimeIntervalOverlapException {
        String keyword = param.get(ParamEnum.KEYWORD).get(0).toLowerCase();
        switch (keyword) {
        case COMPLETED_KEYWORD:
            // get all completed task from storage
            ArrayList<Task> completedTasks = storage.getAllCompletedTasks();
            ArrayList<Task> cloneCompletedTasks = cloner
                    .deepClone(completedTasks);
            for (int i = 0; i < completedTasks.size(); i++) {
                Task task = completedTasks.get(i);
                TaskModifier.deleteTask(task);
                storage.writeTaskToFile(task);
            }
            logicUndo.pushClearCommandToHistory(cloneCompletedTasks);
            return createTaskListFeedback(
                    MessageCreator.createMessage(CLEAR_MESSAGE, null, null),
                    storage.getAllActiveTasks());
        }
        throw new InvalidInputException(MessageCreator.createMessage(
                ERROR_CLEAR_MESSAGE, null, null));
    }

    /**
     * Marks a particular task as done
     *
     * @param param
     *            : the command created by commandParser
     * @return feedback containing the updated list of tasks in the file, and
     *         the message.
     * @throws TaskNotFoundException
     * @throws IOException
     * @throws InvalidInputException
     * @throws InvalidDateFormatException
     * @throws InvalidCommandUseException
     * @throws InvalidInputException
     * @throws TimeIntervalOverlapException
     */
    Feedback complete(Hashtable<ParamEnum, ArrayList<String>> param)
            throws TaskNotFoundException, IOException,
            InvalidDateFormatException, InvalidCommandUseException,
            InvalidInputException, TimeIntervalOverlapException {
        int taskId = getTaskId(param);
        Task task = getTaskFromStorage(taskId);
        if (task.isConfirmed() && task.getDateEnd() == null) {
            TaskModifier.completeTask(param, task);
            String name = task.getName();
            storage.writeTaskToFile(task);
            Task clonedTask = cloner.deepClone(task);
            logicUndo.pushCompleteCommandToHistory(clonedTask);
            ArrayList<Task> taskList = storage.getAllActiveTasks();
            return createTaskListFeedback(
                    MessageCreator.createMessage(COMPLETE_MESSAGE, name, null),
                    taskList);
        } else {
            throw new InvalidCommandUseException(ERROR_COMPLETE_MESSAGE);
        }
    }

    /**
     * Confirms a particular conditional date pair in the conditional task to be
     * used as the start and end date
     *
     * @param param
     *            : the command created by commandParser
     * @return feedback containing the updated list of tasks in the file, and
     *         the message.
     * @throws TaskNotFoundException
     * @throws IOException
     * @throws InvalidInputException
     * @throws TimeIntervalOverlapException
     */

    Feedback confirm(Hashtable<ParamEnum, ArrayList<String>> param)
            throws InvalidInputException, TaskNotFoundException, IOException,
            TimeIntervalOverlapException {
        int taskId = getTaskId(param);
        String dateIdString = param.get(ParamEnum.ID).get(0);
        int dateId;
        try {
            dateId = Integer.parseInt(dateIdString);
        } catch (NumberFormatException e) {
            throw new InvalidInputException(MessageCreator.createMessage(
                    INVALID_DATE_ID_MESSAGE, dateIdString, null));
        }
        Task task = getTaskFromStorage(taskId);
        TaskModifier.confirmTask(dateId, task);
        storage.writeTaskToFile(task);
        Task clonedTask = cloner.deepClone(task);
        logicUndo.pushConfirmCommandToHistory(clonedTask);
        String taskName = task.getName();
        return createTaskAndTaskListFeedback(
                MessageCreator.createMessage(CONFIRM_MESSAGE, taskName, null),
                storage.getAllActiveTasks(), task);
    }

    /**
     * Deletes a task from the storage
     *
     * @param param
     *            : the command created by commandParser
     * @return feedback containing the updated list of tasks in the file, and
     *         the message.
     * @throws TaskNotFoundException
     * @throws IOException
     * @throws InvalidInputException
     */
    Feedback delete(Hashtable<ParamEnum, ArrayList<String>> param)
            throws TaskNotFoundException, IOException, InvalidInputException {
        int taskId = getTaskId(param);
        Task task = getTaskFromStorage(taskId);
        String name = task.getName();
        TaskModifier.deleteTask(task);
        try {
            storage.writeTaskToFile(task);
        } catch (TimeIntervalOverlapException e) {
            // This exception should not be thrown.
            assert false;
        }
        Task clonedTask = cloner.deepClone(task);
        logicUndo.pushDeleteCommandToHistory(clonedTask);
        ArrayList<Task> taskList = storage.getAllActiveTasks();
        return createTaskListFeedback(
                MessageCreator.createMessage(DELETE_MESSAGE, name, null),
                taskList);
    }

    /**
     * Displays all active tasks if no keyword is provided. Otherwise, it will
     * display either active tasks, completed tasks or all tasks depending on
     * the keyword, or the details of a single task if the task id is provided.
     *
     * @param param
     *            : the requirements of the user
     * @return feedback containing the list of all tasks in the file/the task to
     *         be displayed, and the message.
     * @throws TaskNotFoundException
     * @throws InvalidInputException
     */

    Feedback display(Hashtable<ParamEnum, ArrayList<String>> param)
            throws TaskNotFoundException, InvalidInputException {
        String displayString = param.get(ParamEnum.KEYWORD).get(0)
                .toLowerCase();
        logicUndo.pushNullCommandToHistory();
        if (displayString.isEmpty() || displayString.equals(ACTIVE_KEYWORD)) {
            return displayAllActive();
        } else if (displayString.equals(ALL_KEYWORD)) {
            return displayAll();
        } else if (displayString.equals(COMPLETED_KEYWORD)) {
            return displayAllCompleted();
        } else {
            return displayTaskById(displayString);
        }
    }

    /**
     * Display all active tasks in the list
     *
     * @return feedback containing all the tasks in the file, and the message.
     */
    Feedback displayAllActive() {
        ArrayList<Task> taskList = storage.getAllActiveTasks();
        return createTaskListFeedback(MessageCreator.createMessage(
                DISPLAY_MESSAGE, ACTIVE_KEYWORD, null), taskList);
    }

    /**
     * Search for tasks that contain the keyword in the different attributes of
     * the task, such as name, description, tags and dates
     *
     * @param param
     *            : the command created by CommandParser
     * @return feedback containing all the tasks in the file, and the message
     * @throws InvalidInputException
     * @throws InvalidDateFormatException
     */

    Feedback search(Hashtable<ParamEnum, ArrayList<String>> param)
            throws InvalidDateFormatException, InvalidInputException {
        ArrayList<Task> taskList = storage.searchTask(param);
        logicUndo.pushNullCommandToHistory();
        return createTaskListFeedback(
                MessageCreator.createMessage(SEARCH_MESSAGE,
                        String.valueOf(taskList.size()), null), taskList);
    }
    
	// End of segment: src\logic\Logic.java





	/**
	 * origin: src\logic\Logic.java
	 */

    private void addEndTaskToTaskList(ArrayList<Task> taskList, Calendar endTime) {
        Task endTask = new Task();
        endTask.setDateStart(endTime);
        taskList.add(endTask);
    }

    private void addStartTaskToTaskList(ArrayList<Task> taskList,
            Calendar startTime) {
        Task startTask = new Task();
        startTask.setDateEnd(startTime);
        taskList.add(START_VALUE, startTask);
    }

    private boolean isValidTimeSlot(Calendar startTime, Calendar endTime,
            float duration, Calendar curr, Calendar next) {
        return curr.getTimeInMillis() >= startTime.getTimeInMillis()
                && next.getTimeInMillis() <= endTime.getTimeInMillis()
                && (next.getTimeInMillis() - curr.getTimeInMillis()) >= (duration * HOUR_TO_MILLIS);
    }

    /**
     * Add the given interval to the current task and suggestion list
     * @param param
     *           : the requirements specified by the user
     * @param taskList of task within the interval
     * @param duration given by the user for the empty slot
     * @param i the current counter
     * @param suggestionCounter index of the suggestion
     * @param curr
     * @throws InvalidDateFormatException
     * @throws InvalidInputException
     */
    private void addTimeSlotToSuggestion(
            Hashtable<ParamEnum, ArrayList<String>> param,
            ArrayList<Task> taskList, float duration, int i,
            int suggestionCounter, Calendar curr)
            throws InvalidDateFormatException, InvalidInputException {
        Task newTask = new Task();
        newTask.setId(suggestionCounter);
        TaskModifier.modifyTimedTask(param, newTask);
        newTask.setDateStart(curr);
        Calendar temp = (Calendar) curr.clone();
        temp.add(Calendar.SECOND, (int) (duration * HOURS_TO_SECONDS));
        newTask.setDateEnd(temp);
        taskList.add(i + 1, newTask);
        suggestions.add(newTask);
    }

    private boolean hasEmptyDurationParam(
            Hashtable<ParamEnum, ArrayList<String>> param) {
        return param.get(ParamEnum.DURATION).get(0).isEmpty();
    }

    /**
     * Undo the last action taken
     *
     * @return feedback containing the list of updated tasks in the file, and
     *         the message.
     * @throws HistoryNotFoundException
     * @throws TaskNotFoundException
     * @throws IOException
     * @throws TimeIntervalOverlapException
     */
    Feedback undo() throws HistoryNotFoundException, TaskNotFoundException,
            IOException, TimeIntervalOverlapException {
        History lastAction = logicUndo.getLastAction();
        if (lastAction == null) {
            throw new HistoryNotFoundException(ERROR_UNDO_MESSAGE);
        } else {
            ArrayList<Task> tasks = lastAction.getTasks();
            // Add all history task back to current task
            for (Task task : tasks) {
                storage.writeTaskToFile(task);
            }
            if (lastAction.getCommand() == CommandEnum.CLEAR) {
                return createTaskAndTaskListFeedback(
                        MessageCreator.createMessage(UNDO_CLEAR_MESSAGE,
                                lastAction.getCommand().action(), null),
                        storage.getAllActiveTasks(), null);
            } else {
                Task task = tasks.get(0);
                Task displayTask = getTaskDisplayForUndo(task);
                return createTaskAndTaskListFeedback(
                        MessageCreator.createMessage(UNDO_MESSAGE, lastAction
                                .getCommand().action(), task.getName()),
                        storage.getAllActiveTasks(), displayTask);
            }
        }
    }

    /**
     * Updates the task in the file.
     *
     * @param param
     *            : the command created by commandParser
     * @return feedback containing the updated list of tasks in the file, and
     *         the message.
     * @throws TaskNotFoundException
     * @throws IOException
     * @throws InvalidDateFormatException
     * @throws InvalidInputException
     * @throws TimeIntervalOverlapException
     */
    Feedback update(Hashtable<ParamEnum, ArrayList<String>> param)
            throws TaskNotFoundException, IOException,
            InvalidDateFormatException, InvalidInputException,
            TimeIntervalOverlapException {
        int taskId = getTaskId(param);
        Task task = cloner.deepClone(getTaskFromStorage(taskId));
        Task clonedTask = cloner.deepClone(task);
        if (task.isConditionalTask()) {
            updateConditionalTask(param, taskId, task);
        } else if (task.isTimedTask()) {
            updateTimedTask(param, taskId, task);
        } else if (task.isDeadlineTask()) {
            updateDeadlineTask(param, taskId, task);
        } else {
            assert task.isFloatingTask();
            updateFloatingTask(param, task);
        }
        storage.writeTaskToFile(task);
        String name = task.getName();
        ArrayList<Task> taskList = storage.getAllActiveTasks();
        logicUndo.pushUpdateCommandToHistory(clonedTask);
        return createTaskAndTaskListFeedback(
                MessageCreator.createMessage(EDIT_MESSAGE, name, null),
                taskList, task);
    }

    private Feedback createTaskAndTaskListFeedback(String message,
            ArrayList<Task> taskList, Task task) {
        return new Feedback(message, taskList, task);
    }

    private Feedback createTaskFeedback(String message, Task task) {
        return new Feedback(message, null, task);
    }

    private Feedback createTaskListFeedback(String message,
            ArrayList<Task> taskList) {
        return new Feedback(message, taskList, null);
    }

    /**
     * Display all tasks in the list
     *
     * @return feedback containing all the tasks in the file, and the message.
     */
    private Feedback displayAll() {
        ArrayList<Task> taskList = storage.getAllTasks();
        return createTaskListFeedback(
                MessageCreator.createMessage(DISPLAY_MESSAGE, "", null),
                taskList);
    }

    private Feedback displayAllCompleted() {
        ArrayList<Task> taskList = storage.getAllCompletedTasks();
        return createTaskListFeedback(MessageCreator.createMessage(
                DISPLAY_MESSAGE, COMPLETED_KEYWORD, null), taskList);
    }

    /**
     * Displays the individual task
     *
     * @param id
     *            : task id
     * @return feedback containing the task and the message
     * @throws TaskNotFoundException
     *             : if the id is invalid or if it is deleted
     */

    private Feedback displayTask(int id) throws TaskNotFoundException {
        Task task = getTaskFromStorage(id);
        return createTaskFeedback(
                MessageCreator.createMessage(DISPLAY_TASK_MESSAGE,
                        String.valueOf(id), task.getName()), task);
    }

    private Feedback displayTaskById(String displayString)
            throws TaskNotFoundException, InvalidInputException {
        try {
            int id = Integer.parseInt(displayString);
            return displayTask(id);
        } catch (NumberFormatException e) {
            throw new InvalidInputException(MessageCreator.createMessage(
                    ERROR_DISPLAY_MESSAGE, displayString, null));
        }
    }

    private Task getTaskDisplayForUndo(Task task) {
        if (task.isDeleted()) {
            return null;
        } else {
            return task;
        }
    }

    /**
     * Gets the task from storage
     *
     * @param id
     *            : id of task
     * @return task corresponding to the id
     * @throws TaskNotFoundException
     *             : if task is already deleted, or if id is invalid
     */
    private Task getTaskFromStorage(int id) throws TaskNotFoundException {
        Task task = storage.getTask(id);
        if (task.isDeleted()) {
            throw new TaskNotFoundException(MessageCreator.createMessage(
                    ERROR_ALREADY_DELETED_MESSAGE, Integer.toString(id), null));
        }
        return task;
    }

    private Task getTaskFromSuggestion(int taskId) throws TaskNotFoundException, InvalidCommandUseException {
        if (suggestions.isEmpty()) {
            throw new InvalidCommandUseException(MessageCreator.createMessage("There is no suggestion to accept"
                    ,"", null));
        }
        try {
            return suggestions.get(taskId);
        } catch (IndexOutOfBoundsException e) {
            throw new TaskNotFoundException(MessageCreator.createMessage(
                    INVALID_TASK_ID_MESSAGE, Integer.toString(taskId), null));
        }
    }

    private int getTaskId(Hashtable<ParamEnum, ArrayList<String>> param)
            throws InvalidInputException {
        String taskIdString = param.get(ParamEnum.KEYWORD).get(0);
        try {
            return Integer.parseInt(taskIdString);
        } catch (NumberFormatException e) {
            throw new InvalidInputException(MessageCreator.createMessage(
                    INVALID_TASK_ID_MESSAGE, taskIdString, null));
        }
    }

    private boolean hasConditionalTaskParams(
            Hashtable<ParamEnum, ArrayList<String>> param) {
        return hasMultipleEntries(param, ParamEnum.START_DATE)
                && hasMultipleEntries(param, ParamEnum.END_DATE)
                && hasEqualStartAndEndDates(param)
                && !param.containsKey(ParamEnum.DUE_DATE);
    }

    private boolean hasDateParam(Hashtable<ParamEnum, ArrayList<String>> param) {
        return param.containsKey(ParamEnum.START_DATE)
                || param.containsKey(ParamEnum.DUE_DATE)
                || param.containsKey(ParamEnum.END_DATE);

    }

    private boolean hasDeadlineTaskParams(
            Hashtable<ParamEnum, ArrayList<String>> param) {
        return !param.containsKey(ParamEnum.START_DATE)
                && param.containsKey(ParamEnum.DUE_DATE)
                && param.get(ParamEnum.DUE_DATE).size() == 1
                && !param.containsKey(ParamEnum.END_DATE);
    }

    private boolean hasEmptyElements(ArrayList<String> arrayList) {
        for (String s : arrayList) {
            if (s.isEmpty()) {
                return true;
            }
        }
        return false;
    }

    private boolean hasEqualStartAndEndDates(
            Hashtable<ParamEnum, ArrayList<String>> param) {
        return param.get(ParamEnum.START_DATE).size() == param.get(
                ParamEnum.END_DATE).size();
    }

    private boolean hasFloatingTaskParams(
            Hashtable<ParamEnum, ArrayList<String>> param) {
        return !param.containsKey(ParamEnum.START_DATE)
                && !param.containsKey(ParamEnum.DUE_DATE)
                && !param.containsKey(ParamEnum.END_DATE);
    }

    private boolean hasMultipleEntries(
            Hashtable<ParamEnum, ArrayList<String>> param, ParamEnum type) {
        return param.containsKey(type) && param.get(type).size() > 1
                && !hasEmptyElements(param.get(type));
    }

    private boolean hasTimedTaskParams(
            Hashtable<ParamEnum, ArrayList<String>> param) {
        if (param.containsKey(ParamEnum.START_DATE)
                && param.containsKey(ParamEnum.END_DATE)
                && !param.containsKey(ParamEnum.DUE_DATE)) {
            assert (param.get(ParamEnum.START_DATE) != null);
            assert (param.get(ParamEnum.END_DATE) != null);
            return param.get(ParamEnum.START_DATE).size() == 1
                    && !param.get(ParamEnum.START_DATE).get(0).isEmpty()
                    && param.get(ParamEnum.END_DATE).size() == 1
                    && !param.get(ParamEnum.END_DATE).get(0).isEmpty();
        } else {
            return false;
        }
    }

    private boolean hasUpdateTimedTaskParams(
            Hashtable<ParamEnum, ArrayList<String>> param) {
        return !param.containsKey(ParamEnum.DUE_DATE)
                && !(hasMultipleEntries(param, ParamEnum.START_DATE) || hasMultipleEntries(
                        param, ParamEnum.END_DATE));
    }

	// End of segment: src\logic\Logic.java





	/**
	 * origin: src\logic\Logic.java
	 */

    private void updateConditionalTask(
            Hashtable<ParamEnum, ArrayList<String>> param, int taskId, Task task)
            throws InvalidInputException, InvalidDateFormatException {
        if (!hasDateParam(param) || hasConditionalTaskParams(param)) {
            TaskModifier.modifyConditionalTask(param, task);
        } else {
            throw new InvalidInputException(MessageCreator.createMessage(
                    ERROR_UPDATE_CONDITIONAL_TASK_MESSAGE,
                    Integer.toString(taskId), null));
        }
    }

    private void updateDeadlineTask(
            Hashtable<ParamEnum, ArrayList<String>> param, int taskId, Task task)
            throws InvalidDateFormatException, InvalidInputException {
        if (hasDeadlineTaskParams(param) || !hasDateParam(param)) {
            TaskModifier.modifyDeadlineTask(param, task);
        } else if (hasTimedTaskParams(param)) {
            TaskModifier.modifyTimedTask(param, task);
        } else {
            throw new InvalidInputException(MessageCreator.createMessage(
                    ERROR_DATE_INPUT_MESSAGE, Integer.toString(taskId), null));
        }
    }

    private void updateFloatingTask(
            Hashtable<ParamEnum, ArrayList<String>> param, Task task)
            throws InvalidDateFormatException, InvalidInputException {
        if (hasConditionalTaskParams(param)) {
            TaskModifier.modifyConditionalTask(param, task);
        } else if (hasTimedTaskParams(param)) {
            TaskModifier.modifyTimedTask(param, task);
        } else if (hasDeadlineTaskParams(param)) {
            TaskModifier.modifyDeadlineTask(param, task);
        } else if (hasFloatingTaskParams(param)) {
            TaskModifier.modifyFloatingTask(param, task);
        } else {
            throw new InvalidInputException(ERROR_DATE_INPUT_MESSAGE);
        }
    }

    private void updateTimedTask(Hashtable<ParamEnum, ArrayList<String>> param,
            int taskId, Task task) throws InvalidDateFormatException,
            InvalidInputException {
        if (hasUpdateTimedTaskParams(param) || !hasDateParam(param)) {
            TaskModifier.modifyTimedTask(param, task);
        } else if (hasDeadlineTaskParams(param)) {
            TaskModifier.modifyDeadlineTask(param, task);
        } else {
            throw new InvalidInputException(MessageCreator.createMessage(
                    ERROR_DATE_INPUT_MESSAGE, Integer.toString(taskId), null));
        }
    }
}

	// End of segment: src\logic\Logic.java





	/**
	 * origin: src\logic\LogicApi.java
	 */

/**
 * Exhibits the facade pattern. It serves as a wrapper class for the Logic
 * component, and hides the complexity of the logic component from the Main
 * component
 *
 *
 */
public class LogicApi {

    private Logic logic;
    private static LogicApi instance = null;
    private static final String INVALID_COMMAND_MESSAGE = "The command is invalid.";
    private static final String INVALID_BEFORE_AFTER_SEARCH_MESSAGE = "Before and After cannot be searched together.";
    private static final String INVALID_FROM_TO_SEARCH_MESSAGE = "Both start and end date are required.";

    /**
     * This constructor follows the singleton pattern It can only be called with
     * in the current class (LogicApi.getInstance()) This is to ensure that only
     * there is exactly one instance of LogicApi class
     *
     * @return an object instance of LogicApi class.
     * @throws IOException
     * @throws FileFormatNotSupportedException
     */
    public static LogicApi getInstance() throws IOException,
            FileFormatNotSupportedException {
        if (instance == null) {
            instance = new LogicApi();
            ApplicationLogger.getLogger().log(Level.INFO,
                    "Initializing Logic API.");
            instance.logic = Logic.getInstance();
        }
        return instance;
    }

    /**
     * Always creates a new instance of the LogicApi class. For debugging
     * purposes.
     *
     * @return an object instance of the LogicApi class.
     * @throws IOException
     * @throws FileFormatNotSupportedException
     */
    public static LogicApi getNewInstance() throws IOException,
            FileFormatNotSupportedException {
        instance = new LogicApi();
        ApplicationLogger.getLogger()
                .log(Level.INFO, "Initializing Logic API.");
        instance.logic = Logic.getNewInstance();
        return instance;
    }

    private LogicApi() {
    }

    public Feedback displayAllActive() {
        return logic.displayAllActive();
    }

    /**
     * Main function to call to execute command
     *
     * @param the
     *            command created by the commandParser
     * @return the feedback (tasklist and message) corresponding to the
     *         particular command
     * @throws InvalidDateFormatException
     * @throws IOException
     * @throws TaskNotFoundException
     * @throws InvalidInputException
     * @throws HistoryNotFoundException
     * @throws InvalidCommandUseException
     * @throws TimeIntervalOverlapException
     * @throws EmptySearchResultException
     */
    public Feedback executeCommand(Command command)
            throws TaskNotFoundException, IOException,
            InvalidDateFormatException, InvalidInputException,
            HistoryNotFoundException, InvalidCommandUseException,
            TimeIntervalOverlapException {
        if (logic.storage == null) {
            throw new IOException();
        } else {
            ApplicationLogger.getLogger().log(
                    Level.INFO,
                    "Executing command: " + command.getCommand() + " "
                            + command.getParam());
            CommandEnum commandType = command.getCommand();
            Hashtable<ParamEnum, ArrayList<String>> param = command.getParam();
            assert hasKeywordParam(param);
            switch (commandType) {
            case ADD:
                assert hasNameParam(param);
                if (!isNameParamEmpty(param)) {
                    return logic.add(param);
                }
                break;
            case DELETE:
                if (!isKeywordParamEmpty(param)) {
                    return logic.delete(param);
                }
                break;
            case UPDATE:
                if (!isKeywordParamEmpty(param)) {
                    return logic.update(param);
                }
                break;
            case UNDO:
                return logic.undo();
            case DISPLAY:
                return logic.display(param);
            case CLEAR:
                return logic.clear(param);
            case DONE:
                if (!isKeywordParamEmpty(param)) {
                    return logic.complete(param);
                }
                break;
            case SEARCH:
                if (hasSearchParams(param)) {
                    return logic.search(param);
                }
                break;
            case CONFIRM:
                if (!isKeywordParamEmpty(param) && hasIdParam(param)) {
                    return logic.confirm(param);
                }
                break;
            case SUGGEST:
                if (hasStartEndDurationParams(param)) {
                    return logic.suggest(param);
                }
                break;
            case ACCEPT:
                if (!isKeywordParamEmpty(param)) {
                    return logic.accept(param);
                }
            default:
                break;
            }
            throw new InvalidInputException(INVALID_COMMAND_MESSAGE);
        }
    }

    private boolean hasStartEndDurationParams(
            Hashtable<ParamEnum, ArrayList<String>> param) {
        return param.containsKey(ParamEnum.START_DATE)
                && param.containsKey(ParamEnum.END_DATE)
                && param.containsKey(ParamEnum.DURATION);
    }

    private boolean hasBothBeforeAndAfterParams(
            Hashtable<ParamEnum, ArrayList<String>> params) {
        return params.containsKey(ParamEnum.BEFORE)
                && params.containsKey(ParamEnum.AFTER);
    }

    private boolean hasIdParam(Hashtable<ParamEnum, ArrayList<String>> param) {
        return param.containsKey(ParamEnum.ID);
    }

    private boolean hasKeywordParam(
            Hashtable<ParamEnum, ArrayList<String>> param) {
        return param.containsKey(ParamEnum.KEYWORD);
    }

    private boolean hasNameParam(Hashtable<ParamEnum, ArrayList<String>> param) {
        return param.containsKey(ParamEnum.NAME);
    }

    private boolean hasOnlyFromOrToParams(
            Hashtable<ParamEnum, ArrayList<String>> params) {
        return (params.containsKey(ParamEnum.START_DATE) ^ params
                .containsKey(ParamEnum.END_DATE));
    }

    private boolean hasSearchParams(
            Hashtable<ParamEnum, ArrayList<String>> params)
            throws InvalidInputException {
        if (hasBothBeforeAndAfterParams(params)) {
            throw new InvalidInputException(INVALID_BEFORE_AFTER_SEARCH_MESSAGE);
        } else if (hasOnlyFromOrToParams(params)) {
            throw new InvalidInputException(INVALID_FROM_TO_SEARCH_MESSAGE);
        } else {
            return true;
        }
    }

    private boolean isKeywordParamEmpty(
            Hashtable<ParamEnum, ArrayList<String>> param) {
        return param.get(ParamEnum.KEYWORD).get(0).isEmpty();
    }

    private boolean isNameParamEmpty(
            Hashtable<ParamEnum, ArrayList<String>> param) {
        return param.get(ParamEnum.NAME).get(0).isEmpty();
    }

}

	// End of segment: src\logic\LogicApi.java





	/**
	 * origin: src\logic\LogicUndo.java
	 */

/**
 *
 * Provides the methods to add the executed commands to the undo stack, and is
 * responsible for undoing the commands that were executed.
 *
 */
public class LogicUndo {
    private Stack<History> undoStack;

    LogicUndo() {
        undoStack = new Stack<History>();
    }

    /**
     * Creates a version of the new task that is set as deleted, and stores it
     * in the stack
     *
     * @param task
     *            : the new task that is added, it is not set as deleted yet
     */
    void pushAddCommandToHistory(Task task) {
        TaskModifier.deleteTask(task);
        ArrayList<Task> tasks = new ArrayList<Task>();
        tasks.add(task);
        History historyCommand = new History(CommandEnum.ADD, tasks);
        undoStack.push(historyCommand);
    }

    /**
     * Creates a version of the accepted task that is set as deleted, and stores
     * it in the stack
     *
     * @param task
     *            : the new task that is accepted, it is not set as deleted yet
     */
    void pushAcceptCommandToHistory(Task task) {
        TaskModifier.deleteTask(task);
        ArrayList<Task> tasks = new ArrayList<Task>();
        tasks.add(task);
        History historyCommand = new History(CommandEnum.ACCEPT, tasks);
        undoStack.push(historyCommand);
    }

    /**
     * Creates a history object containing the task before it was edited, and
     * stores it in the stack
     *
     * @param task
     *            : the task before it was edited
     */
    void pushUpdateCommandToHistory(Task task) {
        ArrayList<Task> tasks = new ArrayList<Task>();
        tasks.add(task);
        History historyCommand = new History(CommandEnum.UPDATE, tasks);
        undoStack.push(historyCommand);
    }

    /**
     * Creates a history object containing the undeleted version of the task,
     * and stores it in the stack
     *
     * @param task
     *            : the task after it was deleted
     */
    void pushDeleteCommandToHistory(Task task) {
        TaskModifier.undeleteTask(task);
        ArrayList<Task> tasks = new ArrayList<Task>();
        tasks.add(task);
        History historyCommand = new History(CommandEnum.DELETE, tasks);
        undoStack.push(historyCommand);
    }

    /**
     * Creates a history object containing the uncompleted version of the task,
     * and stores it in the stack
     *
     * @param task
     *            : the task after it was completed.
     */
    void pushCompleteCommandToHistory(Task task) {
        TaskModifier.uncompleteTask(task);
        ArrayList<Task> tasks = new ArrayList<Task>();
        tasks.add(task);
        History historyCommand = new History(CommandEnum.DONE, tasks);
        undoStack.push(historyCommand);
    }

    /**
     * Stores a null object in the undo stack. Used for display and search as
     * there is no action to be done to undo it
     */
    void pushNullCommandToHistory() {
        History historyCommand = null;
        undoStack.push(historyCommand);
    }

    /**
     * Stores the unconfirmed version of the task in the undo stack
     *
     * @param task
     *            : the task after it is confirmed
     */
    void pushConfirmCommandToHistory(Task task) {
        TaskModifier.unconfirmTask(task);
        ArrayList<Task> tasks = new ArrayList<Task>();
        tasks.add(task);
        History historyCommand = new History(CommandEnum.CONFIRM, tasks);
        undoStack.push(historyCommand);
    }

    /**
     * Stores the undeleted version of the completed tasks in the undo stack
     *
     * @param task
     *            : the completed tasks
     */
    void pushClearCommandToHistory(ArrayList<Task> tasks) {
        History historyCommand = new History(CommandEnum.CLEAR, tasks);
        undoStack.push(historyCommand);
    }

    /**
     * Returns the inverse action needed to undo the last action taken
     *
     * @return the history object indicating the last action and the reversal
     *         needed to undo it
     * @throws HistoryNotFoundException
     *             when the stack is empty
     */
    History getLastAction() throws HistoryNotFoundException {
        try {
            return undoStack.pop();
        } catch (EmptyStackException e) {
            throw new HistoryNotFoundException(
                    "There are not past actions taken");
        }
    }

}

	// End of segment: src\logic\LogicUndo.java





	/**
	 * origin: src\logic\TaskModifier.java
	 */

/**
 * This class provides the various methods to modify a task, given the command
 * and the task to be modified.
 *
 *
 */
public class TaskModifier {

    private static final int OFFSET_FOR_ARRAY = 1;
    private static final String INVALID_PRIORITY_LEVEL_MESSAGE = "%1$s is not a valid priority level.";
    private static final String INVALID_CONDITIONAL_DATE_ID_MESSAGE = "The conditional date id is invalid.";
    private static final int MIN_ID = 0;
    private static final String INVALID_CONFIRMED_TASK_MESSAGE = "The task is already confirmed.";
    private static final String INVALID_START_END_DATE_MESSAGE = "The start date should occur before the end date";

    /**
     * Marks a task as completed, and updates the end date if it is a deadline
     * task
     *
     * @param param
     *            : the input from the user
     * @param task
     *            : the task to be marked as completed
     * @throws InvalidDateFormatException
     * @throws InvalidInputException
     */
    static void completeTask(Hashtable<ParamEnum, ArrayList<String>> param,
            Task task) throws InvalidDateFormatException, InvalidInputException {
        if (param.containsKey(ParamEnum.DATE)) {
            Calendar completedDate = DateParser.parseString(param.get(
                    ParamEnum.DATE).get(0));
            task.setDateEnd(completedDate);
        } else {
            task.setDateEnd(Calendar.getInstance());
        }

    }

    /**
     * Sets the start and end date of the task from its conditional dates
     *
     * @param dateId
     *            : the id of the conditional date
     * @param event
     *            : the conditional task to be updated
     * @throws InvalidInputException
     */

    static void confirmTask(int dateId, Task event)
            throws InvalidInputException {
        int dateIndex = dateId - OFFSET_FOR_ARRAY;
        if (isLessThanMinId(dateIndex) || hasNullConditionalDates(event)
                || isIdOutsideConditionalDatesRange(dateIndex, event)) {
            throw new InvalidInputException(INVALID_CONDITIONAL_DATE_ID_MESSAGE);
        } else if (event.isConfirmed()) {
            throw new InvalidInputException(INVALID_CONFIRMED_TASK_MESSAGE);
        } else {
            StartEndDatePair conditionalDatesToConfirm = event
                    .getConditionalDates().get(dateIndex);
            Calendar startDate = conditionalDatesToConfirm.getStartDate();
            event.setDateStart(startDate);
            Calendar endDate = conditionalDatesToConfirm.getEndDate();
            event.setDateEnd(endDate);
        }
    }

    static void resetId(Task task) {
        task.setId(Task.ID_FOR_NEW_TASK);
    }

    static void deleteTask(Task task) {
        task.setDeleted(true);
    }

    /**
     * Updates the attributes of the conditional task according to the input
     * given by the user
     *
     * @param param
     *            : the input from the user
     * @param task
     *            : the conditional task to be updated
     * @throws InvalidDateFormatException
     * @throws InvalidInputException
     */
    static void modifyConditionalTask(
            Hashtable<ParamEnum, ArrayList<String>> param, Task task)
            throws InvalidDateFormatException, InvalidInputException {
        setNameFromCommand(param, task);
        setTagsFromCommand(param, task);
        setLevelFromCommand(param, task);
        setNoteFromCommand(param, task);
        setConditionalDatesFromCommand(param, task);
    }

    /**
     * Updates the attributes of the deadline task according to the input given
     * by the user
     *
     * @param param
     *            : the input from the user
     * @param task
     *            : the deadline task to be updated
     * @throws InvalidDateFormatException
     * @throws InvalidInputException
     */
    static void modifyDeadlineTask(
            Hashtable<ParamEnum, ArrayList<String>> param, Task task)
            throws InvalidDateFormatException, InvalidInputException {
        setNameFromCommand(param, task);
        setTagsFromCommand(param, task);
        setLevelFromCommand(param, task);
        setNoteFromCommand(param, task);
        setDueDateFromCommand(param, task);
        setStartAndEndDateToNull(task);
    }

    /**
     * Updates the attributes of the floating task according to the input given
     * by the user
     *
     * @param param
     *            : the input from the user
     * @param task
     *            : the deadline task to be updated
     * @throws InvalidDateFormatException
     * @throws InvalidInputException
     */
    static void modifyFloatingTask(
            Hashtable<ParamEnum, ArrayList<String>> param, Task task)
            throws InvalidDateFormatException, InvalidInputException {
        setNameFromCommand(param, task);
        setTagsFromCommand(param, task);
        setLevelFromCommand(param, task);
        setNoteFromCommand(param, task);
    }

    /**
     *
     * Updates the attributes of the timed task according to the input given by
     * the user
     *
     * @param param
     *            : the input from the user
     * @param task
     *            : the floating task to be updated
     * @throws InvalidDateFormatException
     * @throws InvalidInputException
     */
    static void modifyTimedTask(Hashtable<ParamEnum, ArrayList<String>> param,
            Task task) throws InvalidDateFormatException, InvalidInputException {
        setNameFromCommand(param, task);
        setTagsFromCommand(param, task);
        setLevelFromCommand(param, task);
        setNoteFromCommand(param, task);
        setStartDateFromCommand(param, task);
        setEndDateFromCommand(param, task);
        checkStartDateIsBeforeEndDate(task.getDateStart(), task.getDateEnd());
        setDueDateToNull(task);
    }

    static void uncompleteTask(Task task) {
        assert (task.getDateEnd() != null);
        task.setDateEnd(null);
    }

    static void unconfirmTask(Task task) {
        assert (task.isTimedTask());
        task.setDateStart(null);
        task.setDateEnd(null);
    }

    static void undeleteTask(Task task) {
        assert (task.isDeleted());
        task.setDeleted(false);
    }

    private static void checkStartDateIsBeforeEndDate(Calendar dateStart,
            Calendar dateEnd) throws InvalidInputException {
        if (!isStartDateBeforeEndDate(dateStart, dateEnd)) {
            throw new InvalidInputException(INVALID_START_END_DATE_MESSAGE);
        }
    }

    private static PriorityLevelEnum getPriorityEnumAsInteger(String levelString)
            throws InvalidInputException {
        try {
            return parsePriorityAsInteger(levelString);
        } catch (InvalidPriorityLevelException | NumberFormatException e1) {
            throw new InvalidInputException(MessageCreator.createMessage(
                    INVALID_PRIORITY_LEVEL_MESSAGE, levelString, null));
        }
    }

    private static PriorityLevelEnum getPriorityEnumAsString(String levelString)
            throws InvalidPriorityLevelException {
        return PriorityLevelEnum.fromString(levelString);
    }

    private static PriorityLevelEnum getPriorityLevel(String levelString)
            throws InvalidInputException {
        PriorityLevelEnum priorityEnum;
        try {
            priorityEnum = getPriorityEnumAsString(levelString);
        } catch (InvalidPriorityLevelException e) {
            priorityEnum = getPriorityEnumAsInteger(levelString);
        }
        return priorityEnum;
    }

    private static boolean hasNullConditionalDates(Task task) {
        return task.getConditionalDates() == null;
    }

    private static boolean isIdOutsideConditionalDatesRange(int dateId,
            Task task) {
        return task.getConditionalDates().size() <= dateId;
    }

    private static boolean isLessThanMinId(int dateId) {
        return dateId < MIN_ID;
    }

    private static boolean isStartDateBeforeEndDate(Calendar dateStart,
            Calendar dateEnd) {
        return dateStart.getTimeInMillis() < dateEnd.getTimeInMillis();
    }

    private static PriorityLevelEnum parsePriorityAsInteger(String levelString)
            throws InvalidInputException, InvalidPriorityLevelException {
        int level = Integer.parseInt(levelString);
        return PriorityLevelEnum.fromInteger(level);
    }

    private static void setConditionalDatesFromCommand(
            Hashtable<ParamEnum, ArrayList<String>> param, Task task)
            throws InvalidDateFormatException, InvalidInputException {
        if (param.containsKey(ParamEnum.START_DATE)
                && param.containsKey(ParamEnum.END_DATE)) {
            ArrayList<String> startDates = param.get(ParamEnum.START_DATE);
            ArrayList<String> endDates = param.get(ParamEnum.END_DATE);
            ArrayList<StartEndDatePair> conditionalDates = new ArrayList<StartEndDatePair>();
            for (int i = 0; i < startDates.size(); i++) {
                String startDateString = startDates.get(i);
                String endDateString = endDates.get(i);
                Calendar startDate = DateParser.parseString(startDateString);
                Calendar endDate = DateParser.parseString(endDateString);
                checkStartDateIsBeforeEndDate(startDate, endDate);
                StartEndDatePair datePair = new StartEndDatePair(startDate,
                        endDate);
                conditionalDates.add(datePair);
            }
            task.setConditionalDates(conditionalDates);
        }
    }

    private static void setDueDateFromCommand(
            Hashtable<ParamEnum, ArrayList<String>> param, Task task)
            throws InvalidDateFormatException {
        if (param.containsKey(ParamEnum.DUE_DATE)
                && !param.get(ParamEnum.DUE_DATE).get(0).isEmpty()) {
            Calendar dueDate = DateParser.parseString(param.get(
                    ParamEnum.DUE_DATE).get(0));
            task.setDateDue(dueDate);
        }
    }

    private static void setDueDateToNull(Task task) {
        task.setDateDue(null);
    }

    private static void setEndDateFromCommand(
            Hashtable<ParamEnum, ArrayList<String>> param, Task task)
            throws InvalidDateFormatException {
        if (param.containsKey(ParamEnum.END_DATE)
                && !param.get(ParamEnum.END_DATE).get(0).isEmpty()) {
            Calendar endDate = DateParser.parseString(param.get(
                    ParamEnum.END_DATE).get(0));
            task.setDateEnd(endDate);
        }
    }

    private static void setLevelFromCommand(
            Hashtable<ParamEnum, ArrayList<String>> param, Task task)
            throws InvalidInputException {
        if (param.containsKey(ParamEnum.LEVEL)) {
            assert param.get(ParamEnum.LEVEL).size() == 1;
            String levelString = param.get(ParamEnum.LEVEL).get(0);
            PriorityLevelEnum priorityEnum = getPriorityLevel(levelString);
            task.setPriorityLevel(priorityEnum);
        }
    }

    private static void setNameFromCommand(
            Hashtable<ParamEnum, ArrayList<String>> param, Task task) {
        if (param.containsKey(ParamEnum.NAME)) {
            String taskName = param.get(ParamEnum.NAME).get(0);
            task.setName(taskName);
        }
    }

    private static void setNoteFromCommand(
            Hashtable<ParamEnum, ArrayList<String>> param, Task task) {
        if (param.containsKey(ParamEnum.NOTE)) {
            String note = param.get(ParamEnum.NOTE).get(0);
            task.setNote(note);
        }
    }

    private static void setStartAndEndDateToNull(Task task) {
        task.setDateStart(null);
        task.setDateEnd(null);
    }

    private static void setStartDateFromCommand(
            Hashtable<ParamEnum, ArrayList<String>> param, Task task)
            throws InvalidDateFormatException {
        if (param.containsKey(ParamEnum.START_DATE)
                && !param.get(ParamEnum.START_DATE).get(0).isEmpty()) {
            Calendar startDate = DateParser.parseString(param.get(
                    ParamEnum.START_DATE).get(0));
            task.setDateStart(startDate);
        }
    }

    private static void setTagsFromCommand(
            Hashtable<ParamEnum, ArrayList<String>> param, Task task) {
        if (param.containsKey(ParamEnum.TAG)) {
            ArrayList<String> tags = param.get(ParamEnum.TAG);
            task.setTags(tags);
        }
    }
}

	// End of segment: src\logic\TaskModifier.java





	/**
	 * origin: src\tests\IntegrationTest.java
	 */

public class IntegrationTest {

    CommandParser parser;
    LogicApi logicApiObject;

    @Before
    public void clearData() throws IOException, FileFormatNotSupportedException {
        PrintWriter writer = new PrintWriter("taskStorage.data");
        writer.print("");
        writer.close();
        parser = new CommandParser();
        logicApiObject = LogicApi.getNewInstance();
    }

    @Test
    /**
     * Tests that task can be added
     * @throws Exception
     */
    public final void testAddTask() throws Exception {
        Command addCommand = parser
                .parseCommand("add eat my pet dog from 20 February 2015 to 21 February 2015 note I don't know why I want that? level red");
        Feedback feedback = logicApiObject.executeCommand(addCommand);
        Task newTask = feedback.getTaskList().get(0);
        assertEquals("eat my pet dog", newTask.getName());
        assertEquals("I don't know why I want that?", newTask.getNote());
        assertEquals(PriorityLevelEnum.RED, newTask.getPriorityLevel());
        assertEquals(20, newTask.getDateStart().get(Calendar.DAY_OF_MONTH));
        assertEquals(2, newTask.getDateStart().get(Calendar.MONTH) + 1);
        assertEquals(2015, newTask.getDateStart().get(Calendar.YEAR));
        assertEquals(21, newTask.getDateEnd().get(Calendar.DAY_OF_MONTH));
        assertEquals(2, newTask.getDateEnd().get(Calendar.MONTH) + 1);
        assertEquals(2015, newTask.getDateEnd().get(Calendar.YEAR));
    }

    public final void testAddMultipleTasks() throws Exception {
        Command addCommand = parser
                .parseCommand("add eat my pet dog from 20 February 2015 to 21 February 2015 note I don't know why I want that? level 2");
        logicApiObject.executeCommand(addCommand);
        addCommand = parser
                .parseCommand("add second from 22 February 2015 to 23 February 2015 note I don't know why I want that? level 2");
        Feedback feedback = logicApiObject.executeCommand(addCommand);
        assertEquals(2, feedback.getTaskList().size());
        Task firstTask = feedback.getTaskList().get(0);
        Task secondTask = feedback.getTaskList().get(1);
        assertEquals("eat my pet dog", firstTask.getName());
        assertEquals("second", secondTask.getName());
    }

    @Test
    /**
     * Tests that active tasks are displayed by default
     * @throws Exception
     */
    public final void testDefaultDisplay() throws Exception {
        Command addCommand = parser
                .parseCommand("add eat my pet dog from 20 February 2015 to 21 February 2015");
        logicApiObject.executeCommand(addCommand);
        Command nextAddCommand = parser
                .parseCommand("add another from 21 February 2014 to 21 February 2014");
        Feedback feedback = logicApiObject.executeCommand(nextAddCommand);
        Task newTask = feedback.getTaskList().get(0);
        assertEquals(1, feedback.getTaskList().size());
        assertEquals("eat my pet dog", newTask.getName());
        assertEquals(20, newTask.getDateStart().get(Calendar.DAY_OF_MONTH));
        assertEquals(2, newTask.getDateStart().get(Calendar.MONTH) + 1);
        assertEquals(2015, newTask.getDateStart().get(Calendar.YEAR));
        assertEquals(21, newTask.getDateEnd().get(Calendar.DAY_OF_MONTH));
        assertEquals(2, newTask.getDateEnd().get(Calendar.MONTH) + 1);
        assertEquals(2015, newTask.getDateEnd().get(Calendar.YEAR));
    }

    /**
     * Tests that start date must be before end date when adding a task
     *
     * @throws Exception
     */
    @Test(expected = InvalidInputException.class)
    public final void testStartDateCannotBeAfterEndDateForAdd()
            throws Exception {
        Command addCommand = parser
                .parseCommand("add test from 20 Feb 2015 to 19 Feb 2015");
        logicApiObject.executeCommand(addCommand);
    }

    /**
     * Tests that start date before end date when adding a conditional task
     *
     * @throws Exception
     */
    @Test(expected = InvalidInputException.class)
    public final void testStartDateCannotBeAfterEndDateForConditionalTask()
            throws Exception {
        Command addCommand = parser
                .parseCommand("add test from 21 Feb 2015 to 20 Feb 2015 or from 20 Feb 2015 to 21 Feb 2015");
        logicApiObject.executeCommand(addCommand);
    }

    /**
     * Tests that start date must be before end date when updating a task
     *
     * @throws Exception
     */
    @Test(expected = InvalidInputException.class)
    public final void testStartDateCannotBeAfterEndDateForUpdate()
            throws Exception {
        Command addCommand = parser
                .parseCommand("add test from 20 Jan 2015 to 20 Feb 2015");
        logicApiObject.executeCommand(addCommand);
        Command updateCommand = parser
                .parseCommand("update 1 from 21 Feb 2015");
        logicApiObject.executeCommand(updateCommand);
    }

    /**
     * Tests that an invalid priority level cannot be added
     *
     * @throws Exception
     */
    @Test(expected = InvalidInputException.class)
    public final void testCannotAddTaskWithInvalidPriorityInt() throws Exception {
        Command addCommand = parser.parseCommand("add test level -1");
        logicApiObject.executeCommand(addCommand);
    }

    /**
     * Tests that an invalid priority level cannot be added
     *
     * @throws Exception
     */
    @Test(expected = InvalidInputException.class)
    public final void testCannotAddTaskWithInvalidPriorityInt2()
            throws Exception {
        Command addCommand = parser.parseCommand("add test level 4");
        logicApiObject.executeCommand(addCommand);
    }

    /**
     * Tests that an invalid priority level cannot be added
     *
     * @throws Exception
     */
    @Test(expected = InvalidInputException.class)
    public final void testCannotAddTaskWithInvalidPriorityString()
            throws Exception {
        Command addCommand = parser.parseCommand("add test level gren");
        logicApiObject.executeCommand(addCommand);
    }

    /**
     * Tests that a task must have a name before it is added
     *
     * @throws Exception
     */
    @Test(expected = InvalidInputException.class)
    public final void testCannotAddTaskWithoutName() throws Exception {
        Command addCommand = parser
                .parseCommand("add from 20 Feb 2015 due 21 Feb 2015 note I don't know why I want that? level 2");
        logicApiObject.executeCommand(addCommand);
    }

    /**
     * Tests that tasks that are absent cannot be displayed
     *
     * @throws Exception
     */
    @Test(expected = TaskNotFoundException.class)
    public final void testCannotDisplayAbsentTask() throws Exception {
        Command addCommand = parser.parseCommand("add eat my pet dog");
        logicApiObject.executeCommand(addCommand);
        Command displayCommand = parser.parseCommand("display 2");
        logicApiObject.executeCommand(displayCommand);
    }

    /**
     * Tests that tasks with invalid id cannot be displayed
     *
     * @throws Exception
     */
    @Test(expected = TaskNotFoundException.class)
    public final void testCannotDisplayTaskWithNegativeId() throws Exception {
        Command addCommand = parser.parseCommand("add eat my pet dog");
        logicApiObject.executeCommand(addCommand);
        Command displayCommand = parser.parseCommand("display 0");
        logicApiObject.executeCommand(displayCommand);
    }

    @Test
    /**
     * Tests that a deleted task cannot be updated anymore
     *
     * @throws Exception
     */
    (expected = TaskNotFoundException.class)
    public final void testCannotModifyDeleteTask() throws Exception {
        Command addCommand = parser
                .parseCommand("add eat my pet dog note I don't know why I want that? level 2");
        Feedback feedback = logicApiObject.executeCommand(addCommand);
        Task task = feedback.getTaskList().get(0);
        assertTrue(!task.isDeleted());
        Command deleteCommand = parser.parseCommand("delete 1");
        Feedback deletedFeedback = logicApiObject.executeCommand(deleteCommand);
        assertEquals(new ArrayList<Task>(), deletedFeedback.getTaskList());
        Command updateCommand = parser.parseCommand("update 1 name blah");
        logicApiObject.executeCommand(updateCommand);
    }

    /**
     * Tests that display cannot be undone
     *
     * @throws Exception
     */
    @Test(expected = HistoryNotFoundException.class)
    public final void testCannotUndoDisplayTask() throws Exception {
        CommandParser parser = new CommandParser();
        Command displayCommand = parser.parseCommand("display");
        logicApiObject.executeCommand(displayCommand);
        Command undoCommand = parser.parseCommand("undo");
        logicApiObject.executeCommand(undoCommand);
    }

    /**
     * Tests that undo cannot be done if there are no prior actions taken
     *
     * @throws Exception
     */
    @Test(expected = HistoryNotFoundException.class)
    public final void testCannotUndoWithoutHistory() throws Exception {
        Command undoCommand = parser.parseCommand("undo");
        logicApiObject.executeCommand(undoCommand);
    }

    /**
     * Tests that a task must have a keyword before it is deleted
     *
     * @throws Exception
     */
    @Test(expected = InvalidInputException.class)
    public final void testCannotUpdateTaskWithoutId() throws Exception {
        Command addCommand = parser.parseCommand("add test");
        logicApiObject.executeCommand(addCommand);
        Command updateCommand = parser
                .parseCommand("update from 20 Feb 2015 due 21 Feb 2015 note I don't know why I want that? level 2");
        logicApiObject.executeCommand(updateCommand);
    }

    @Test
    /**
     * Tests that the task can be marked as completed
     * @throws Exception
     */
    public final void testCompleteTask() throws Exception {
        Command addCommand = parser
                .parseCommand("add eat my pet dog due 20 Feb 2015 note I don't know why I want that? level 2");
        Feedback feedback = logicApiObject.executeCommand(addCommand);
        Task uncompletedTask = feedback.getTaskList().get(0);
        assertTrue(uncompletedTask.getDateEnd() == null);
        Command completeCommand = parser.parseCommand("done 1");
        logicApiObject.executeCommand(completeCommand);
        Command displayCommand = parser.parseCommand("display completed");
        Feedback completedFeedback = logicApiObject
                .executeCommand(displayCommand);
        assertEquals(1, completedFeedback.getTaskList().size());
        assertTrue(completedFeedback.getTaskList().get(0).isCompleted());
    }

    @Test
    /**
     * Tests that a task can be completed with a specified complete date
     * @throws Exception
     */
    public final void testCompleteTaskWithDate() throws Exception {
        Command addCommand = parser.parseCommand("add eat my pet dog");
        Feedback feedback = logicApiObject.executeCommand(addCommand);
        Task uncompletedTask = feedback.getTaskList().get(0);
        assertNull(uncompletedTask.getDateEnd());
        Command completeCommand = parser
                .parseCommand("done 1 date 30 January 2015");
        logicApiObject.executeCommand(completeCommand);
        Command displayCommand = parser.parseCommand("display completed");
        Feedback completedFeedback = logicApiObject
                .executeCommand(displayCommand);
        Task completedTask = completedFeedback.getTaskList().get(0);
        assertTrue(completedFeedback.getTaskList().get(0).isCompleted());
        assertEquals(30, completedTask.getDateEnd().get(Calendar.DAY_OF_MONTH));
        assertEquals(1, completedTask.getDateEnd().get(Calendar.MONTH) + 1);
        assertEquals(2015, completedTask.getDateEnd().get(Calendar.YEAR));
    }

    /**
     * Tests that conditional dates are added correctly
     *
     * @throws Exception
     */
    @Test
    public final void testConditionalTasks() throws Exception {
        Command addCommand = parser
                .parseCommand("Add CS2103T from 23 Dec 1992 00:00 to 23 Dec 2002 00:00 or from 7 Oct 2013 00:00 to 8 Oct 2013 00:00");
        Feedback feedback = logicApiObject.executeCommand(addCommand);
        Task task = feedback.getTaskList().get(0);
        assertEquals("Task name is correct", "CS2103T", task.getName());
        assertTrue("Conditional dates are present", task.getConditionalDates()
                .size() == 2);
        assertEquals(
                "First start date is correct",
                "23 Dec 1992 00:00",
                DateParser.parseCalendar(task.getConditionalDates().get(0)
                        .getStartDate()));
        assertEquals(
                "Second start date is correct",
                "7 Oct 2013 00:00",
                DateParser.parseCalendar(task.getConditionalDates().get(1)
                        .getStartDate()));
        assertEquals(
                "First due date is correct",
                "23 Dec 2002 00:00",
                DateParser.parseCalendar(task.getConditionalDates().get(0)
                        .getEndDate()));
        assertEquals(
                "Second due date is correct",
                "8 Oct 2013 00:00",
                DateParser.parseCalendar(task.getConditionalDates().get(1)
                        .getEndDate()));
    }

    /**
     * Tests that conditional tasks can be confirmed with a valid id
     *
     * @throws Exception
     */
    @Test
    public final void testConfirmConditionalTasks() throws Exception {
        CommandParser parser = new CommandParser();
        Command addCommand = parser
                .parseCommand("Add CS2103T from 23 Dec 2015 to 24 Dec 2015 or from 7 Oct 2016 to 8 Oct 2016");
        logicApiObject.executeCommand(addCommand);
        Command confirmCommand = parser.parseCommand("confirm 1 id 2");
        Feedback feedback = logicApiObject.executeCommand(confirmCommand);
        Task task = feedback.getTaskList().get(0);
        assertEquals("Task name is correct", "CS2103T", task.getName());
        assertTrue("Task is confirmed", task.isConfirmed());
        assertEquals("Confirmed start date is correct", task
                .getConditionalDates().get(1).getStartDate(),
                task.getDateStart());
        assertEquals("Confirmed due date is correct", task
                .getConditionalDates().get(1).getEndDate(), task.getDateEnd());
    }

    /**
     * Tests that error will be thrown if invalid date id is given for
     * confirming conditional tasks Boundary testing
     *
     * @throws Exception
     */
    @Test(expected = InvalidInputException.class)
    public final void testConfirmConditionalTasksWithInvalidId()
            throws Exception {
        CommandParser parser = new CommandParser();
        Command addCommand = parser
                .parseCommand("Add CS2103T from 23 Dec 1992 to 23 Dec 2002 or from 7 Oct 2014 to 8 Oct 2014");
        logicApiObject.executeCommand(addCommand);
        Command confirmCommand = parser.parseCommand("confirm 1 id 3");
        logicApiObject.executeCommand(confirmCommand);
    }

    /**
     * Tests that error will be thrown if invalid date id is given for
     * confirming conditional tasks Boundary testing
     *
     * @throws Exception
     */
    @Test(expected = InvalidInputException.class)
    public final void testConfirmConditionalTasksWithNegativeId()
            throws Exception {
        CommandParser parser = new CommandParser();
        Command addCommand = parser
                .parseCommand("Add CS2103T from 23 Dec 1992 to 23 Dec 2002 or from 7 Oct 2014 to 8 Oct 2014");
        logicApiObject.executeCommand(addCommand);
        Command confirmCommand = parser.parseCommand("confirm 1 id -1");
        logicApiObject.executeCommand(confirmCommand);
    }

    @Test
    /**
     * Tests that a task can be deleted
     * @throws Exception
     */
    public final void testDeleteTask() throws Exception {
        Command addCommand = parser
                .parseCommand("add eat my pet dog due 20 Feb 2015 note I don't know why I want that? level 2");
        Feedback feedback = logicApiObject.executeCommand(addCommand);
        Task task = feedback.getTaskList().get(0);
        assertTrue(!task.isDeleted());
        Command deleteCommand = parser.parseCommand("delete 1");
        Feedback completedFeedback = logicApiObject
                .executeCommand(deleteCommand);
        assertEquals(0, completedFeedback.getTaskList().size());
    }

    @Test
    /**
     * Tests that display all tasks display the correct tasks
     * @throws Exception
     */
    public final void testDisplayAll() throws Exception {
        Command addCommand = parser.parseCommand("add first");
        logicApiObject.executeCommand(addCommand);
        addCommand = parser.parseCommand("add second thing");
        logicApiObject.executeCommand(addCommand);
        Command displayCommand = parser.parseCommand("display");
        Feedback feedback = logicApiObject.executeCommand(displayCommand);
        assertEquals("Task length is correct", 2, feedback.getTaskList().size());
        assertNull("Task Display is empty", feedback.getTaskDisplay());
    }

    @Test
    /**
     * Tests that an individual task can be displayed
     * @throws Exception
     */
    public final void testDisplayIndividualTask() throws Exception {
        Command addCommand = parser.parseCommand("add eat my pet dog");
        logicApiObject.executeCommand(addCommand);
        Command displayCommand = parser.parseCommand("display 1");
        Feedback feedback = logicApiObject.executeCommand(displayCommand);
        assertEquals("ID is the same", 1, feedback.getTaskDisplay().getId());
        assertEquals("Name is correct", "eat my pet dog", feedback
                .getTaskDisplay().getName());
        assertNull("Task list is empty", feedback.getTaskList());
    }

    /**
     * Tests that tasks can be filtered by active status
     *
     * @throws Exception
     */
    @Test
    public final void testFilterActiveTask() throws Exception {
        CommandParser parser = new CommandParser();
        Command addCommand = parser
                .parseCommand("Add completed task due 10 Oct 2013");
        logicApiObject.executeCommand(addCommand);
        Command completeCommand = parser.parseCommand("done 1");
        logicApiObject.executeCommand(completeCommand);
        addCommand = parser.parseCommand("Add uncompleted task");
        logicApiObject.executeCommand(addCommand);
        Command filterCommand = parser.parseCommand("display");
        Feedback feedback = logicApiObject.executeCommand(filterCommand);
        ArrayList<Task> taskList = feedback.getTaskList();
        assertEquals("Only 1 task is shown", 1, taskList.size());
    }

    /**
     * Tests that tasks can be filtered by completed status
     *
     * @throws Exception
     */
    @Test
    public final void testFilterCompletedTask() throws Exception {
        CommandParser parser = new CommandParser();
        Command addCommand = parser
                .parseCommand("Add completed task due 23 December 2002");
        logicApiObject.executeCommand(addCommand);
        Command completeCommand = parser.parseCommand("done 1");
        logicApiObject.executeCommand(completeCommand);
        addCommand = parser.parseCommand("Add uncompleted task");
        logicApiObject.executeCommand(addCommand);
        Command filterCommand = parser.parseCommand("display completed");
        Feedback feedback = logicApiObject.executeCommand(filterCommand);
        ArrayList<Task> taskList = feedback.getTaskList();
        assertEquals("Only 1 task is shown", 1, taskList.size());
    }

    /**
     * Tests that add task can be undone by deleting the task
     *
     * @throws Exception
     */
    @Test
    public final void testUndoAddTask() throws Exception {
        CommandParser parser = new CommandParser();
        Command addCommand = parser
                .parseCommand("Add blah from 23 December 1992 to 23 December 2002");
        logicApiObject.executeCommand(addCommand);
        Command undoCommand = parser.parseCommand("undo");
        Feedback feedback = logicApiObject.executeCommand(undoCommand);
        assertEquals("No task is displayed", 0, feedback.getTaskList().size());
    }

    /**
     * Tests that delete task can be undone
     *
     * @throws Exception
     */
    @Test
    public final void testUndoDeleteTask() throws Exception {
        CommandParser parser = new CommandParser();
        Command addCommand = parser
                .parseCommand("Add blah from 23 December 2015 to 23 December 2015");
        logicApiObject.executeCommand(addCommand);
        Command deleteCommand = parser.parseCommand("Delete 1");
        logicApiObject.executeCommand(deleteCommand);
        Command undoCommand = parser.parseCommand("undo");
        Feedback feedback = logicApiObject.executeCommand(undoCommand);
        assertEquals(1, feedback.getTaskList().size());
        assertEquals("blah", feedback.getTaskList().get(0).getName());

    }

    /**
     * Tests that update task can be undone
     *
     * @throws Exception
     */
    @Test
    public final void testUndoUpdateTask() throws Exception {
        CommandParser parser = new CommandParser();
        Command addCommand = parser
                .parseCommand("Add blah due 23 December 1992");
        logicApiObject.executeCommand(addCommand);
        Command updateCommand = parser.parseCommand("Update 1 name changed");
        Feedback oldFeedback = logicApiObject.executeCommand(updateCommand);
        assertEquals("changed", oldFeedback.getTaskList().get(0).getName());
        Command undoCommand = parser.parseCommand("undo");
        Feedback feedback = logicApiObject.executeCommand(undoCommand);
        assertEquals(1, feedback.getTaskList().size());
        assertEquals("blah", feedback.getTaskList().get(0).getName());
    }

    @Test
    /**
     * Tests that task can be updated
     * @throws Exception
     */
    public final void testUpdateTask() throws Exception {
        Command addCommand = parser
                .parseCommand("add eat my pet dog from 20 Feb 2015 to 21 Feb 2015 note I don't know why I want that? level 3");
        logicApiObject.executeCommand(addCommand);
        Command updateCommand = parser
                .parseCommand("update 1 name changed from 01 Jan 2015 note changed description level 2");
        Feedback feedback = logicApiObject.executeCommand(updateCommand);
        Task newTask = feedback.getTaskList().get(0);
        assertEquals("changed", newTask.getName());
        assertEquals("changed description", newTask.getNote());
        assertEquals(PriorityLevelEnum.ORANGE, newTask.getPriorityLevel());
        assertEquals(1, newTask.getDateStart().get(Calendar.DAY_OF_MONTH));
        assertEquals(1, newTask.getDateStart().get(Calendar.MONTH) + 1);
        assertEquals(2015, newTask.getDateStart().get(Calendar.YEAR));
        assertEquals(21, newTask.getDateEnd().get(Calendar.DAY_OF_MONTH));
        assertEquals(2, newTask.getDateEnd().get(Calendar.MONTH) + 1);
        assertEquals(2015, newTask.getDateEnd().get(Calendar.YEAR));
    }

}
	// End of segment: src\tests\IntegrationTest.java





