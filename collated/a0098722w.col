//@author: a0098722w



	/**
	 * origin: src\command\CommandAlias.java
	 */

public enum CommandAlias {
    ADD(CommandEnum.ADD, "add"),
    DELETE(CommandEnum.DELETE, "delete", "remove"),
    UPDATE(CommandEnum.UPDATE, "modify", "update"),
    UNDO(CommandEnum.UNDO, "undo"),
    SEARCH(CommandEnum.SEARCH, "search", "find"),
    DISPLAY(CommandEnum.DISPLAY, "display", "show"),
    DONE(CommandEnum.DONE, "done", "complete"),
    CONFIRM(CommandEnum.CONFIRM, "confirm"),
    CLEAR(CommandEnum.CLEAR, "clear"),
    TAB(CommandEnum.TAB, "tab"),
    SUGGEST(CommandEnum.SUGGEST, "suggest"),
    ACCEPT(CommandEnum.ACCEPT, "accept");

    private final CommandEnum command;
    private final String[] alias;

    CommandAlias(CommandEnum command, String... aliasList) {
        this.command = command;
        this.alias = aliasList;
    }

    public CommandEnum command() {
        return this.command;
    }

    public String[] alias() {
        return this.alias;
    }

}

	// End of segment: src\command\CommandAlias.java





	/**
	 * origin: src\command\CommandEnum.java
	 */

/**
 * This enum describe the different kind of params enum that are allowed for
 * each of the command
 *
 *
 *
 */
public enum CommandEnum {
    ADD("add", ParamEnum.NAME, ParamEnum.DUE_DATE, ParamEnum.OR_END,
        ParamEnum.OR_FROM, ParamEnum.DATE, ParamEnum.START_DATE,
        ParamEnum.END_DATE, ParamEnum.LEVEL, ParamEnum.NOTE, ParamEnum.TAG),
    DELETE("delete", ParamEnum.KEYWORD),
    UPDATE("update", ParamEnum.KEYWORD, ParamEnum.DUE_DATE, ParamEnum.OR_END,
        ParamEnum.OR_FROM, ParamEnum.DATE, ParamEnum.START_DATE,
        ParamEnum.END_DATE,ParamEnum.LEVEL, ParamEnum.NOTE, ParamEnum.TAG, ParamEnum.NAME),
    UNDO("undo", ParamEnum.KEYWORD),
    SEARCH("search", ParamEnum.KEYWORD, ParamEnum.NAME, ParamEnum.NOTE,
        ParamEnum.TAG, ParamEnum.AFTER, ParamEnum.BEFORE,
        ParamEnum.START_DATE, ParamEnum.END_DATE, ParamEnum.ON),
    DISPLAY("display", ParamEnum.KEYWORD),
    DONE("done", ParamEnum.KEYWORD, ParamEnum.DATE),
    COMPLETE("complete", ParamEnum.KEYWORD, ParamEnum.DATE),
    CONFIRM("confirm", ParamEnum.KEYWORD, ParamEnum.ID),
    CLEAR("clear", ParamEnum.KEYWORD),
    TAB("tab", ParamEnum.KEYWORD),
    SUGGEST ("suggest", ParamEnum.NAME, ParamEnum.START_DATE, ParamEnum.END_DATE, ParamEnum.DURATION),
    ACCEPT ("accept", ParamEnum.KEYWORD);

    private final String action;
    private final ParamEnum commandKey;
    private final ParamEnum[] params;

    /**
     *
     * @param action
     *            The action of the command
     * @param associatedParams
     *            Additional params associated with the command
     */
    CommandEnum(String action, ParamEnum commandKey,
            ParamEnum... associatedParams) {
        this.action = action;
        this.commandKey = commandKey;
        params = associatedParams;
    }

    public String action() {
        return action;
    }

    public ParamEnum[] params() {
        return params;
    }

    public ParamEnum commandKey() {
        return commandKey;
    }

}
	// End of segment: src\command\CommandEnum.java





	/**
	 * origin: src\command\CommandParser.java
	 */

/**
 * This class helps to recognize the command given by the user from its string
 * format, and format it into the common Command object that could then be
 * process easily by the other components of the project.
 *
 *
 *
 */
public class CommandParser {

    private static final String LOG_COMMAND_PARSED = "Parse user command string: \"%1$s\".";
    private static final int FIRST_GROUP = 1;
    private static final String FIRST_WORD_PATTERN = "^([\\w]+)";
    private static final String INDIVIDUAL_PARAM_PATTERN = "%1$s|";
    private static final String COMMAND_PATTERN = "(%1$s)(.*?)(?=%2$s$)";
    private static final String COMPLETE_PATTERN = "(%1$s|%2$s)(.*?)(?=%3$s$)";
    private static final String ESCAPE_SEQUENCE = "\\";

    private static final String INVALID_COMMAND_MESSAGE = "%1$s is not a valid command";

    private static final Integer ENUM_TYPE = 1;
    private static final Integer ENUM_ARGUMENT = 2;

    private Hashtable<String, CommandEnum> commandEnumTable = new Hashtable<String, CommandEnum>();
    private Hashtable<String, ParamEnum> paramEnumTable = new Hashtable<String, ParamEnum>();

    public CommandParser() {
        initializeCommandTable();
        initializeParamTable();
    }

    /**
     * THe operation parse a given command string into a command object
     *
     * @param commandString
     * @return command object representing the given command string
     * @throws Exception
     */
    public Command parseCommand(String commandString) throws Exception {
        assert commandString != null;
        ApplicationLogger.getLogger()
        .log(Level.INFO, String.format(LOG_COMMAND_PARSED,commandString));
        
        CommandEnum commandType = getCommandType(commandString);
        String commandTypeString = getFirstWord(commandString);

        Command userCommand = new Command(commandType);
        parseCommandStringToCommand(userCommand, commandString,
                commandTypeString);
        return userCommand;
    }

    /**
     * This operation parse the command string arguments to the command object
     *
     * @param userCommand
     * @param commandString
     */
    private void parseCommandStringToCommand(Command userCommand,
            String commandString, String commandTypeString) {
        CommandEnum commandType = userCommand.getCommand();

        String commandPatternString = makeCommandPatternString(commandType,
                commandTypeString);
        String patternString = makePatternString(commandType, commandTypeString);

        addParams(userCommand, commandString, commandPatternString,
                patternString);
        addCommandString(userCommand, commandString);
    }

    /**
     * This operation map all the params of command string to its enum type
     *
     * @param userCommand
     * @param commandString
     * @param patternString
     */
    private void addParams(Command userCommand, String commandString,
            String commandPatternString, String patternString) {

        // commandString without the initial command and its argument
        String commandSubString = null;

        Pattern commandPattern = Pattern.compile(commandPatternString,
                Pattern.CASE_INSENSITIVE);
        Matcher commandMatcher = commandPattern.matcher(commandString);

        if (commandMatcher.find()) {
            String argumentEscape = escapeKeyword(commandMatcher.group(
                    ENUM_ARGUMENT).trim());
            userCommand.addCommandArgument(argumentEscape);
            commandSubString = commandString.substring(commandMatcher.end());
        }

        Pattern pattern = Pattern.compile(patternString,
                Pattern.CASE_INSENSITIVE);
        Matcher matcher = pattern.matcher(commandSubString);

        ParamEnum paramEnum;
        while (matcher.find()) {
            if (paramEnumTable.containsKey(matcher.group(ENUM_TYPE))) {
                paramEnum = paramEnumTable.get(matcher.group(ENUM_TYPE));
                String escaped = escapeKeyword(matcher.group(ENUM_ARGUMENT)
                        .trim());
                ParamEnum groupName = paramEnumTable.get(paramEnum.groupName());
                userCommand.addParam(groupName, escaped);
            }
        }
    }

    /**
     * This operation add the user command string to the command object
     *
     * @param userCommand
     * @param commandString
     */
    private void addCommandString(Command userCommand, String commandString) {
        userCommand.addCommandString(commandString);
    }

    private String makeCommandPatternString(CommandEnum commandType,
            String commandTypeString) {
        String paramsStartPatternString = makeParamsPatternString(commandType);
        String commandPatternString = String.format(COMMAND_PATTERN,
                commandTypeString, paramsStartPatternString);

        return commandPatternString;
    }

    /**
     * This operation return a pattern string for the given command type
     *
     * @param commandType
     * @return
     */
    private String makePatternString(CommandEnum commandType,
            String commandTypeString) {
        assert commandType != null;
        String paramsPatternString = makeParamsPatternString(commandType);
        String completePattern = String.format(COMPLETE_PATTERN,
                commandTypeString, paramsPatternString, paramsPatternString);
        return completePattern;
    }

    /**
     * This operation returns a pattern string consist of all the params of the
     * command type
     *
     * @param commandType
     * @return
     */
    private String makeParamsPatternString(CommandEnum commandType) {
        assert commandType != null;
        ParamEnum[] params = commandType.params();
        String paramsPattern = "";
        
        for (ParamEnum param : params) {
            paramsPattern += String.format(INDIVIDUAL_PARAM_PATTERN,
                    param.regex());
        }

        return paramsPattern;
    }

    private CommandEnum getCommandType(String commandString) throws Exception {
        assert commandString != null;
        String firstWord = getFirstWord(commandString).toLowerCase();
        if (commandEnumTable.containsKey(firstWord)) {
            return commandEnumTable.get(firstWord);
        } else {
            throw new Exception(String.format(INVALID_COMMAND_MESSAGE,
                    firstWord));
        }
    }

    private String getFirstWord(String commandString) {
        Pattern pattern = Pattern.compile(FIRST_WORD_PATTERN);
        Matcher matcher = pattern.matcher(commandString);

        if (matcher.find()) {
            return matcher.group(FIRST_GROUP);
        } else {
            return null;
        }
    }

    private void initializeCommandTable() {
        for (CommandAlias commandAlias : CommandAlias.values()) {
            for (String regex : commandAlias.alias()) {
                commandEnumTable.put(regex, commandAlias.command());
            }
        }
    }

    private void initializeParamTable() {
        for (ParamEnum param : ParamEnum.values()) {
            paramEnumTable.put(param.regex().replace("\\", ""), param);
        }
    }

    /**
     * This operation escape keyword found in the param string
     *
     * @param paramString
     * @return
     */
    private String escapeKeyword(String paramString) {
        String resultString = paramString.replace(ESCAPE_SEQUENCE, "");

        return resultString;
    }
}

	// End of segment: src\command\CommandParser.java





	/**
	 * origin: src\command\ParamEnum.java
	 */

/**
 * This enum class describe the regex keyword that for each of the param command
 *
 *
 *
 */
public enum ParamEnum {
    KEYWORD("", ""),
    DATE(" date", ""),
    NOTE(" note", ""),
    LEVEL(" level", ""),
    TAG(" \\+", " +"),
    DUE_DATE(" due", ""),
    START_DATE(" from", ""),
    END_DATE(" to ", ""),
    ORDER_BY(" order by", ""),
    OR_FROM(" or from", " from"),
    OR_END(" or to ", " to"),
    NAME(" name", ""),
    ID(" id", ""),
    BEFORE(" before", ""),
    AFTER(" after", ""),
    ON(" on", ""),
    DURATION (" duration", "");

    private final String regex;
    private final String groupName;

    ParamEnum(String regex, String groupName) {
        this.regex = regex;
        this.groupName = groupName;
    }

    public String regex() {
        return this.regex;
    }

    public String groupName() {
        return this.groupName.isEmpty() ? this.regex : this.groupName;
    }
}

	// End of segment: src\command\ParamEnum.java





	/**
	 * origin: src\common\Command.java
	 */

/**
 * This class acts a a common object for different components of the project to
 * interpret the given command of the user
 * 
 * 
 *
 */
public class Command {

    private String commandString;
    private CommandEnum commandType;
    private String commandArgument;
    private Hashtable<ParamEnum, ArrayList<String>> params;

    public Command(CommandEnum commandType) {
        this.commandType = commandType;
        params = new Hashtable<ParamEnum, ArrayList<String>>();
    }

    public void addCommandString(String userCommandString) {
        commandString = userCommandString;
    }

    public void addCommandArgument(String arg) {
        addParam(commandType.commandKey(), arg);
    }

    public void addParam(ParamEnum param, String args) {
        if (!params.containsKey(param)) {
            ArrayList<String> newArgsList = new ArrayList<String>();
            params.put(param, newArgsList);
        }

        params.get(param).add(args);
    }

    public Hashtable<ParamEnum, ArrayList<String>> getParam() {
        return params;
    }

    public String getCommandString() {
        return commandString;
    }

    public CommandEnum getCommand() {
        return commandType;
    }

    public String getCommandArgument() {
        return commandArgument;
    }
}

	// End of segment: src\common\Command.java





	/**
	 * origin: src\common\DateParser.java
	 */

public class DateParser {
    private static final String INVALID_DATE_FORMAT_MESSAGE = "Date format: '%1$s' is invalid!";
    private static final String DISPLAY_DATE_FORMAT = "%d %s %02d:%02d";
    private static final String FULL_DISPLAY_DATE_FORMAT = "%d %s %d %02d:%02d";
    private static final String CONVERSION_DATE_FORMAT = "\\d\\d[\\\\\\-\\.]\\d\\d[\\\\\\-\\.]\\d{2}(?:\\d{2})?";
    private static final String CORRECT_DATE_FORMAT = "%1$s-%2$s-%3$s";
    private static final String DATE_SPLIT_FORMAT = "[\\\\\\-\\.]";
    private static final int MONTH = 0;
    private static final int DAY = 1;
    private static final int YEAR = 2;
    private static final int INVALID_FORMAT = 1;

    /**
     * Reads a date in the string format, and returns its corresponding calendar
     * representation
     *
     * @param dateString
     *            : date in string format
     * @return the calendar object representing the date
     * @throws InvalidDateFormatException
     */
    public static Calendar parseString(String dateString)
            throws InvalidDateFormatException {
        if (dateString.isEmpty()) {
            return null;
        }
        return nattyDateParser(formatDate(dateString));
    }

    /**
     * Parse a given date given in given natural language into its corresponding
     * calendar representation
     *
     * @param dateString
     *            : A string in any natural format representing a correct date
     * @return the calendar object representing the date
     * @throws InvalidDateFormatException
     */
    private static Calendar nattyDateParser(String dateString)
            throws InvalidDateFormatException {
        Parser parser = new Parser();
        List<DateGroup> groups = parser.parse(dateString);
        Calendar inputDate = null;
        for (DateGroup group : groups) {
            List<Date> dates = group.getDates();
            if (dates.size() > INVALID_FORMAT) {
                throw new InvalidDateFormatException(MessageCreator.createMessage(INVALID_DATE_FORMAT_MESSAGE, dateString, null));
            } else {
                inputDate = new GregorianCalendar();
                inputDate.setTime(dates.get(0));
            }
        }
        if (inputDate == null) {
            throw new InvalidDateFormatException(MessageCreator.createMessage(INVALID_DATE_FORMAT_MESSAGE, dateString, null));
        }

        return inputDate;
    }

	// End of segment: src\common\DateParser.java





	/**
	 * origin: src\common\DateParser.java
	 */

    /**
     * Format a date from dd-mm-yyyy format into natty acceptable date format
     *
     * @param date
     *            : string representation of a date
     * @return corrected date format
     */
    private static String formatDate(String date) {
        String correctedDate = "";
        Pattern pattern = Pattern.compile(CONVERSION_DATE_FORMAT);
        Matcher m = pattern.matcher(date);
        if (m.find()) {
            String[] dateComponents = date.split(DATE_SPLIT_FORMAT);
            correctedDate = String.format(CORRECT_DATE_FORMAT,
                    dateComponents[DAY], dateComponents[MONTH],
                    dateComponents[YEAR]);
        } else {
            correctedDate = date;
        }

        return correctedDate;
    }
}
	// End of segment: src\common\DateParser.java





	/**
	 * origin: src\logic\Logic.java
	 */

    /**
     * Suggest a list of date that fulfill the user requirements
     *
     * @param param
     *            : the requirements specified by the user
     * @return feedback containing the list of free slots ======= Suggest a list
     *         of dates that fulfill the user requirements
     *
     * @param param
     * @return Feedback
     * @throws InvalidDateFormatException
     * @throws InvalidInputException
     */
    Feedback suggest(Hashtable<ParamEnum, ArrayList<String>> param)
            throws InvalidDateFormatException, InvalidInputException {
        if (!hasTimedTaskParams(param) || hasEmptyDurationParam(param)) {
            throw new InvalidInputException(ERROR_SUGGEST_MESSAGE);
        }
        suggestions.clear();
        
        ArrayList<Task> taskList = storage.suggestedSearchTask(param);
        // Round off the given time interval to the nearest 30min block
        // and add into tasklist to facilitate search
        Calendar startTime = processDateString(param
                .get(ParamEnum.START_DATE).get(START_VALUE));
        Calendar endTime = processDateString(param
                .get(ParamEnum.END_DATE).get(START_VALUE));
        addStartTaskToTaskList(taskList, startTime);
        addEndTaskToTaskList(taskList, endTime);
        
        float duration = getDuration(param);
        assert duration > MAX_INVALID_DURATION;

        generateSuggestions(param, taskList, startTime, endTime, duration);
        String message = getSuggestionMessage();

        return createTaskAndTaskListFeedback(
                MessageCreator.createMessage(message, "", null), suggestions,
                null);
    }

    /**
     * Process the date to ensure that it starts after current time and is round off to the nearest block
     * @param dateString
     * @return
     * @throws InvalidDateFormatException
     */
    private Calendar processDateString(String dateString) throws InvalidDateFormatException {
        Calendar userInputTime = DateParser.parseString(dateString);
        if (userInputTime.before(Calendar.getInstance())) {
            return roundToNearestBlock(Calendar.getInstance());
        } else {
            return roundToNearestBlock(userInputTime);
        }
    }

    private String getSuggestionMessage() {
        String message;
        if (suggestions.isEmpty()) {
            message = NO_SUGGESTION_MESSAGE;
        } else {
            message = SUGGESTION_MESSAGE;
        }
        return message;
    }

    private float getDuration(Hashtable<ParamEnum, ArrayList<String>> param)
            throws InvalidInputException {
        float duration;
        String durationString = param.get(ParamEnum.DURATION).get(START_VALUE);
        try {
            duration = Float.parseFloat(durationString);
        } catch (NumberFormatException e) {
            throw new InvalidInputException(MessageCreator.createMessage(
                    "Duration %1$s is invalid.", durationString, null));
        }
        if (duration <= MAX_INVALID_DURATION) {
            throw new InvalidInputException(MessageCreator.createMessage(
                    "Duration %1$s is invalid.", durationString, null));
        }
        return duration;
    }

    /**
     * Look for empty slot within the given interval which satisfy the user duration
     * @param param
     *           : the requirements specified by the user
     * @param taskList of all the task in the interval
     * @param startTime of the interval to find the empty slot
     * @param endTime of the interval to find the empty slot
     * @param duration of the empty slot to look for
     * @throws InvalidDateFormatException
     * @throws InvalidInputException
     */
    private void generateSuggestions(
            Hashtable<ParamEnum, ArrayList<String>> param,
            ArrayList<Task> taskList, Calendar startTime, Calendar endTime,
            float duration) throws InvalidDateFormatException,
            InvalidInputException {
        int suggestionCounter = 1;
        while (suggestions.size() < MAX_RESULT) {
            int i;
            Calendar curr;
            Calendar next;
            for (i = 0; i < taskList.size() - 1; i++) {
                curr = roundToNearestBlock(taskList.get(i).getDateEnd());
                next = roundToNearestBlock(taskList.get(i + NEXT).getDateStart());
                if (isValidTimeSlot(startTime, endTime, duration, curr, next)) {
                    addTimeSlotToSuggestion(param, taskList, duration, i,
                            suggestionCounter, curr);
                    suggestionCounter++;
                    System.out.println(suggestionCounter);
                    break;
                }
            }
            // Exit from the loop if no results is found
            if (i == taskList.size() - 1) {
                break;
            }
        }
    }

	// End of segment: src\logic\Logic.java





	/**
	 * origin: src\logic\Logic.java
	 */

    /**
     * Return a calendar to the nearest thirty minutes block
     *
     * @param date
     * @return a calendar object a with the nearest block
     */
    private Calendar roundToNearestBlock(Calendar date) {
        long dateTime = date.getTimeInMillis();
        if (dateTime % TIME_BLOCK == 0) {
            return date;
        } else {
            dateTime = ((dateTime / TIME_BLOCK) + NEXT) * TIME_BLOCK;
            Calendar nearestBlock = Calendar.getInstance();
            nearestBlock.setTimeInMillis(dateTime);
            return nearestBlock;
        }
    }

	// End of segment: src\logic\Logic.java





	/**
	 * origin: src\tests\CommandParserTest.java
	 */

public class CommandParserTest {

    CommandParser cp;

    @Before
    public void initialize() {
        cp = new CommandParser();
    }
    
    @Test
    /**
     * Test adding of a single param for a param type
     * @throws Exception
     */
    public void testAddSingleParamPerParamType() throws Exception {
        String oneKind = "add test1 +oneKind";
        Command oneKindResult = cp.parseCommand(oneKind);
        ArrayList<String> oneKindArray = new ArrayList<String>();
        oneKindArray.add("oneKind");
        assertEquals(oneKindArray,
                oneKindResult.getParam().get(ParamEnum.TAG));
    }
    
    @Test
    /**
     * Test adding of a multiple param for a param type
     * @throws Exception
     */
    public void testAddMultipleParamPerParamType() throws Exception {
        String multipleKind = "add test1 +oneKind +twoKind +threeKind";
        Command multipleKindResult = cp.parseCommand(multipleKind);
        ArrayList<String> multipleKindArray = new ArrayList<String>();
        multipleKindArray.add("oneKind");
        multipleKindArray.add("twoKind");
        multipleKindArray.add("threeKind");
        assertEquals(3, multipleKindResult.getParam().get(ParamEnum.TAG).size());
        assertEquals(multipleKindArray, multipleKindResult.getParam().get(ParamEnum.TAG));
    }

    // Test the command parser on different combinations of dates 
    @Test
    /**
     * Test command parser on a single due date
     * This is the boundary case for adding only one due date
     * @throws Exception
     */
    public void testSingleDate() throws Exception {
        String oneDate = "add test1 due 12-12-12";
        Command oneDateResult = cp.parseCommand(oneDate);
        ArrayList<String> oneDateArray = new ArrayList<String>();
        oneDateArray.add("12-12-12");
        assertEquals(oneDateArray,
                oneDateResult.getParam().get(ParamEnum.DUE_DATE));
    }
    
    @Test
    /**
     * Test the command parser on a date pair
     * This is the boundary for a single case of date pair
     * @throws Exception
     */
    public void testDatePair() throws Exception {
        String fromDueDate = "add test2 from 11-11-11 to 11-11-12";
        Command fromDueDateResult = cp.parseCommand(fromDueDate);
        ArrayList<String> dueDateArray = new ArrayList<String>();
        dueDateArray.add("11-11-12");
        ArrayList<String> fromDateArray = new ArrayList<String>();
        fromDateArray.add("11-11-11");
        assertEquals(dueDateArray,
                fromDueDateResult.getParam().get(ParamEnum.END_DATE));
        assertEquals(fromDateArray,
                fromDueDateResult.getParam().get(ParamEnum.START_DATE));
    }
    
    @Test
    /**
     * This is the boundary for a multiple case of date pair
     * @throws Exception
     */
    public void testMultipleConditionalDatePair() throws Exception {
        String multipleDate = "add test2 from 11-11-11 to 11-11-12 or from 12-12-11 to 12-12-12";
        Command multipleDateResult = cp.parseCommand(multipleDate);
        ArrayList<String> multipleDueDateArray = new ArrayList<String>();
        multipleDueDateArray.add("11-11-12");
        multipleDueDateArray.add("12-12-12");
        ArrayList<String> multipleFromDateArray = new ArrayList<String>();
        multipleFromDateArray.add("11-11-11");
        multipleFromDateArray.add("12-12-11");
        assertEquals(multipleDueDateArray,
            multipleDateResult.getParam().get(ParamEnum.END_DATE));
        assertEquals(multipleFromDateArray,
            multipleDateResult.getParam().get(ParamEnum.START_DATE));
    }
    
    
    // Test the command parser on different combinations of parameters
    
    @Test
    /**
     * Test command parser on a single paramters
     * @throws Exception
     */
    public void testSingleParam() throws Exception {
        String singleParam = "add test1";
        Command singleParamResult = cp.parseCommand(singleParam);
        
        ArrayList<String> nameArray = new ArrayList<String>();
        nameArray.add("test1");
        assertEquals(nameArray, singleParamResult.getParam().get(ParamEnum.NAME));
    }
    
    @Test
    /**
     * Test command parser on adding multiple parameters
     * @throws Exception
     */
    public void testMultipleParam() throws Exception {
        String multipleParam = "add test1 from 12-12-12 to 13-12-12 note testtesttest +abc + def";
        Command multipleParamResult = cp.parseCommand(multipleParam);
        
        ArrayList<String> startDateArray = new ArrayList<String>();
        startDateArray.add("12-12-12");
        assertEquals(startDateArray,
                multipleParamResult.getParam().get(ParamEnum.START_DATE));
        
        ArrayList<String> endDateArray = new ArrayList<String>();
        endDateArray.add("13-12-12");
        assertEquals(endDateArray, multipleParamResult.getParam().get(ParamEnum.END_DATE));
        
        ArrayList<String> noteArray = new ArrayList<String>();
        noteArray.add("testtesttest");
        assertEquals(noteArray, multipleParamResult.getParam().get(ParamEnum.NOTE));
        
        ArrayList<String> tagArray = new ArrayList<String>();
        tagArray.add("abc");
        tagArray.add("def");
        assertEquals(tagArray, multipleParamResult.getParam().get(ParamEnum.TAG));
    }
    
    @Test
    /**
     * Test the command parser to parse the same command string with different order of inputs params
     * @throws Exception
     */
    public void testOrderOfParam() throws Exception {
        String orderedParam = "add test1 due 13-12-12 note testtesttest +abc + def";
        Command orderedParamResult = cp.parseCommand(orderedParam);
        
        ArrayList<String> endDateArray = new ArrayList<String>();
        endDateArray.add("13-12-12");
        assertEquals(endDateArray, orderedParamResult.getParam().get(ParamEnum.DUE_DATE));
        
        ArrayList<String> tagArray = new ArrayList<String>();
        tagArray.add("abc");
        tagArray.add("def");
        assertEquals(tagArray, orderedParamResult.getParam().get(ParamEnum.TAG));
        
        ArrayList<String> noteArray = new ArrayList<String>();
        noteArray.add("testtesttest");
        assertEquals(noteArray, orderedParamResult.getParam().get(ParamEnum.NOTE));
        
        String unorderedParam = "add test1 +abc note testtesttest due 13-12-12 + def";
        Command unorderedParamResult = cp.parseCommand(unorderedParam);
        
        assertEquals(endDateArray, unorderedParamResult.getParam().get(ParamEnum.DUE_DATE));      
        assertEquals(tagArray, unorderedParamResult.getParam().get(ParamEnum.TAG));
        assertEquals(noteArray, unorderedParamResult.getParam().get(ParamEnum.NOTE));
    }
    
    @Test
    /**
     * Test the escape functionality of the command parser
     * @throws Exception
     */
    public void testEscapeParam() throws Exception {
        String escapedParam = "add test1 from 12-12-12 to 13-12-12 note give present \\to anna";
        Command escapedParamResult = cp.parseCommand(escapedParam);
        
        // The actual end date from the "to" param
        ArrayList<String> endDateArray = new ArrayList<String>();
        endDateArray.add("13-12-12");
        assertEquals(endDateArray, escapedParamResult.getParam().get(ParamEnum.END_DATE));
        
        ArrayList<String> noteArray = new ArrayList<String>();
        noteArray.add("give present to anna");
        assertEquals(noteArray, escapedParamResult.getParam().get(ParamEnum.NOTE));
    }
}

	// End of segment: src\tests\CommandParserTest.java





	/**
	 * origin: src\tests\IntervalSearchTest.java
	 */

public class IntervalSearchTest {

    IntervalSearch tr;

    @Before
    public void initializeTest() {
        tr = new IntervalSearch();

        Calendar start = new GregorianCalendar(2014, 11, 12);
        Calendar end = new GregorianCalendar(2014, 11, 13);
        tr.add(start, end, 3);

        Calendar secondStart = new GregorianCalendar(2014, 11, 15);
        Calendar secondEnd = new GregorianCalendar(2014, 11, 18);
        tr.add(secondStart, secondEnd, 4);

        Calendar thirdStart = new GregorianCalendar(2014, 8, 10);
        Calendar thirdEnd = new GregorianCalendar(2014, 9, 12);
        tr.add(thirdStart, thirdEnd, 5);
    }

    @Test
    /**
     * This test the add date function of the interval search
     */
    public void testAddDate() {
        int currentSize = tr.size();

        Calendar newStart = new GregorianCalendar(2014, 10, 3);
        Calendar newEnd = new GregorianCalendar(2014, 10, 4);
        tr.add(newStart, newEnd, 5);
        int newSize = tr.size();

        assertEquals(1, (newSize - currentSize));
    }

    @Test
    /**
     * This test the get interval function of the interval search
     */
    public void testGetInterval() {
        Calendar searchStart = new GregorianCalendar(2014, 11, 1);
        Calendar searchEnd = new GregorianCalendar(2014, 11, 30);

        HashMap<Calendar, Calendar> results = tr.getOccupiedIntervals(
                searchStart, searchEnd);
        assertTrue(results.size() == 2);

        Calendar testStart = new GregorianCalendar(2014, 11, 15);
        Calendar testEnd = new GregorianCalendar(2014, 11, 18);

        assertEquals(testEnd.getTimeInMillis(), results.get(testStart)
                .getTimeInMillis());

        Calendar testStart2 = new GregorianCalendar(2014, 11, 12);
        Calendar testEnd2 = new GregorianCalendar(2014, 11, 13);

        assertEquals(testEnd2.getTimeInMillis(), results.get(testStart2)
                .getTimeInMillis());
    }

    @Test
    /**
     * This test the get intervalId function of the interval search
     */
    public void testGetIntervalId() {
        Calendar searchStart = new GregorianCalendar(2014, 11, 1);
        Calendar searchEnd = new GregorianCalendar(2014, 11, 30);

        ArrayList<Integer> results = tr.getTasksWithinInterval(searchStart,
                searchEnd);
        assertTrue(results.size() == 2);

        assertFalse(results.contains(5));
        assertTrue(results.contains(4));
        assertTrue(results.contains(3));
    }

    @Test
    /**
     * This test the get task id beyond a specific date function of interval search
     */
    public void testGetIdFromDate() {
        Calendar searchStart = new GregorianCalendar(2014, 11, 1);

        ArrayList<Integer> results = tr.getTasksFrom(searchStart);
        assertTrue(results.size() == 2);

        assertFalse(results.contains(5));
        assertTrue(results.contains(4));
        assertTrue(results.contains(3));
    }

    @Test
    /**
     * This test the update function of interval search
     */
    public void testUpdate() {
        Calendar oldStart = new GregorianCalendar(2014, 11, 12);
        Calendar oldEnd = new GregorianCalendar(2014, 11, 13);

        Calendar newStart = new GregorianCalendar(2014, 11, 13);
        Calendar newEnd = new GregorianCalendar(2014, 11, 14);

        tr.update(oldStart, oldEnd, newStart, newEnd, 3);
        assertEquals(-1, tr.get(oldStart, oldEnd));
        assertEquals(3, tr.get(newStart, newEnd));

    }

}

	// End of segment: src\tests\IntervalSearchTest.java





	/**
	 * origin: src\tests\LogicTest.java
	 */

public class LogicTest {
    Class<LogicApi> logicApiClass = LogicApi.class;
    Class<Logic> logicClass = Logic.class;
    Class<TaskModifier> taskModifierClass = TaskModifier.class;
    Field logic = logicApiClass.getDeclaredField("logic");
    Method update = logicClass.getDeclaredMethod("update", Hashtable.class);
    Method add = logicClass.getDeclaredMethod("add", Hashtable.class);
    Method complete = logicClass.getDeclaredMethod("complete", Hashtable.class);
    Method delete = logicClass.getDeclaredMethod("delete", Hashtable.class);
    Method display = logicClass.getDeclaredMethod("display", Hashtable.class);
    LogicApi logicApiObject;
    Logic logicObject;
    int thisYear = Calendar.getInstance().get(Calendar.YEAR);

    public LogicTest() throws NoSuchMethodException, NoSuchFieldException {
    }

    @Before
    public void clearData() throws FileNotFoundException {
        PrintWriter writer = new PrintWriter("taskStorage.data");
        writer.print("");
        writer.close();
    }

    @Before
    public void getLogicAndStorage() throws IllegalArgumentException,
    IllegalAccessException, IOException,
            FileFormatNotSupportedException {
        logicApiObject = LogicApi.getNewInstance();
        logicObject = (Logic) logic.get(logicApiObject);
    }

    @Before
    public void setFieldsAccessible() {
        logic.setAccessible(true);

    }

    @Before
    public void setFunctionsAccessible() {
        add.setAccessible(true);
        complete.setAccessible(true);
        delete.setAccessible(true);
        update.setAccessible(true);
        display.setAccessible(true);
    }

    @Test
    /**
     * Test the addition of a new new task object
     * @throws IllegalAccessException
     * @throws IllegalArgumentException
     * @throws InvocationTargetException
     */
    public void testAdd() throws IllegalAccessException,
    IllegalArgumentException, InvocationTargetException {
        Hashtable<ParamEnum, ArrayList<String>> params = new Hashtable<ParamEnum, ArrayList<String>>();
        ArrayList<String> nameList = new ArrayList<String>();
        nameList.add("test test");
        params.put(ParamEnum.NAME, nameList);
        ArrayList<String> noteList = new ArrayList<String>();
        noteList.add("Test is good");
        params.put(ParamEnum.NOTE, noteList);
        ArrayList<String> priorityList = new ArrayList<String>();
        priorityList.add("RED");
        params.put(ParamEnum.LEVEL, priorityList);
        Feedback feedback = (Feedback) add.invoke(logicObject, params);
        assertEquals(1, feedback.getTaskList().size());
        Task task = feedback.getTaskList().get(0);
        assertEquals("Test is good", task.getNote());
        assertEquals("test test", task.getName());
        assertEquals(PriorityLevelEnum.RED, task.getPriorityLevel());
    }

    @Test
    /**
     * Test adding of prioority level to a task
     * @throws IllegalAccessException
     * @throws IllegalArgumentException
     * @throws InvocationTargetException
     */
    public void testAddWithIntPriorityLevel() throws IllegalAccessException,
    IllegalArgumentException, InvocationTargetException {
        Hashtable<ParamEnum, ArrayList<String>> params = new Hashtable<ParamEnum, ArrayList<String>>();
        ArrayList<String> nameList = new ArrayList<String>();
        nameList.add("test test");
        ArrayList<String> priorityList = new ArrayList<String>();
        priorityList.add("3");
        params.put(ParamEnum.LEVEL, priorityList);

        Feedback feedback = (Feedback) add.invoke(logicObject, params);
        assertEquals(1, feedback.getTaskList().size());
        Task task = feedback.getTaskList().get(0);
        assertEquals(PriorityLevelEnum.RED, task.getPriorityLevel());
    }

    @Test
    /**
     * Test that a task can be successfully delete from the tasklist
     * @throws IllegalAccessException
     * @throws IllegalArgumentException
     * @throws InvocationTargetException
     */
    public void testDelete() throws IllegalAccessException,
    IllegalArgumentException, InvocationTargetException {
        Hashtable<ParamEnum, ArrayList<String>> params = new Hashtable<ParamEnum, ArrayList<String>>();
        ArrayList<String> nameList = new ArrayList<String>();
        nameList.add("test test");
        params.put(ParamEnum.NAME, nameList);
        ArrayList<String> noteList = new ArrayList<String>();
        noteList.add("Test is good");
        params.put(ParamEnum.NOTE, noteList);
        add.invoke(logicObject, params);

        Hashtable<ParamEnum, ArrayList<String>> deleteParams = new Hashtable<ParamEnum, ArrayList<String>>();
        ArrayList<String> numList = new ArrayList<String>();
        numList.add("1");
        deleteParams.put(ParamEnum.KEYWORD, numList);
        Feedback deleteFeedback = (Feedback) delete.invoke(logicObject,
                deleteParams);
        assertEquals(0, deleteFeedback.getTaskList().size());
    }

    @Test
    /**
     * Test that a test can be succesfully completed
     * @throws IllegalAccessException
     * @throws IllegalArgumentException
     * @throws InvocationTargetException
     */
    public void testCompleted() throws IllegalAccessException,
    IllegalArgumentException, InvocationTargetException {
        Hashtable<ParamEnum, ArrayList<String>> params = new Hashtable<ParamEnum, ArrayList<String>>();
        ArrayList<String> nameList = new ArrayList<String>();
        nameList.add("test test");
        params.put(ParamEnum.NAME, nameList);
        ArrayList<String> noteList = new ArrayList<String>();
        noteList.add("Test is good");
        params.put(ParamEnum.NOTE, noteList);
        add.invoke(logicObject, params);

        Hashtable<ParamEnum, ArrayList<String>> completeParams = new Hashtable<ParamEnum, ArrayList<String>>();
        ArrayList<String> numList = new ArrayList<String>();
        numList.add("1");
        completeParams.put(ParamEnum.KEYWORD, numList);
        complete.invoke(logicObject,
                completeParams);

        Hashtable<ParamEnum, ArrayList<String>> displayParams = new Hashtable<ParamEnum, ArrayList<String>>();
        ArrayList<String> displayList = new ArrayList<String>();
        displayList.add("completed");
        displayParams.put(ParamEnum.KEYWORD, displayList);
        Feedback displayFeedback = (Feedback) display.invoke(logicObject,
                displayParams);
        assertEquals(1, displayFeedback.getTaskList().size());

        Task task = displayFeedback.getTaskList().get(0);
        assertTrue(task.isCompleted());
    }

    @Test
    /**
     * Test the update method of a task
     * @throws IllegalAccessException
     * @throws IllegalArgumentException
     * @throws InvocationTargetException
     */
    public void testUpdate() throws IllegalAccessException,
    IllegalArgumentException, InvocationTargetException {
        Hashtable<ParamEnum, ArrayList<String>> params = new Hashtable<ParamEnum, ArrayList<String>>();
        ArrayList<String> nameList = new ArrayList<String>();
        nameList.add("test test");
        params.put(ParamEnum.NAME, nameList);
        Feedback feedback = (Feedback) add.invoke(logicObject, params);

        Task task = feedback.getTaskList().get(0);
        assertTrue(task.getNote().isEmpty());

        Hashtable<ParamEnum, ArrayList<String>> updateParams = new Hashtable<ParamEnum, ArrayList<String>>();
        ArrayList<String> noteList = new ArrayList<String>();
        noteList.add("Test is good");
        updateParams.put(ParamEnum.NOTE, noteList);
        ArrayList<String> dueDateList = new ArrayList<String>();
        dueDateList.add("20 Oct 2015 9am");
        updateParams.put(ParamEnum.DUE_DATE, dueDateList);
        ArrayList<String> numList = new ArrayList<String>();
        numList.add("1");
        updateParams.put(ParamEnum.KEYWORD, numList);
        Feedback updateFeedback = (Feedback) update.invoke(logicObject,
                updateParams);
        assertEquals(1, updateFeedback.getTaskList().size());
        task = updateFeedback.getTaskList().get(0);

        assertEquals("Test is good", task.getNote());
        assertTrue(task.isDeadlineTask());
        if (thisYear == 2015) {
            assertEquals("20 Oct 09:00",
                DateParser.parseCalendar(task.getDateDue()));
        } else {
            assertEquals("20 Oct 2015 09:00",
                DateParser.parseCalendar(task.getDateDue()));
        }

    }

    @Test
    /**
     * Test that a task can be updated from a deadline task to a timed task
     * @throws IllegalAccessException
     * @throws IllegalArgumentException
     * @throws InvocationTargetException
     */
    public void testUpdateDeadlineToTimed() throws IllegalAccessException,
    IllegalArgumentException, InvocationTargetException {
        Hashtable<ParamEnum, ArrayList<String>> params = new Hashtable<ParamEnum, ArrayList<String>>();
        ArrayList<String> nameList = new ArrayList<String>();
        nameList.add("test test");
        params.put(ParamEnum.NAME, nameList);
        ArrayList<String> dueDateList = new ArrayList<String>();
        dueDateList.add("20 Oct 2015 9am");
        params.put(ParamEnum.DUE_DATE, dueDateList);
        Feedback feedback = (Feedback) add.invoke(logicObject, params);

        Task task = feedback.getTaskList().get(0);
        assertTrue(task.getNote().isEmpty());

        Hashtable<ParamEnum, ArrayList<String>> updateParams = new Hashtable<ParamEnum, ArrayList<String>>();
        ArrayList<String> startDateList = new ArrayList<String>();
        startDateList.add("23 Oct 2015 09:00");
        updateParams.put(ParamEnum.START_DATE, startDateList);
        ArrayList<String> endDateList = new ArrayList<String>();
        endDateList.add("23 Oct 2015 11:00");
        updateParams.put(ParamEnum.END_DATE, endDateList);
        ArrayList<String> numList = new ArrayList<String>();
        numList.add("1");
        updateParams.put(ParamEnum.KEYWORD, numList);
        Feedback updateFeedback = (Feedback) update.invoke(logicObject,
                updateParams);
        assertEquals(1, updateFeedback.getTaskList().size());
        task = updateFeedback.getTaskList().get(0);

        assertTrue(task.isTimedTask());

        if (thisYear == 2015) {
            assertEquals("23 Oct 09:00",
                DateParser.parseCalendar(task.getDateStart()));
            assertEquals("23 Oct 11:00",
                DateParser.parseCalendar(task.getDateEnd()));
        } else {
            assertEquals("23 Oct 2015 09:00",
                DateParser.parseCalendar(task.getDateStart()));
            assertEquals("23 Oct 2015 11:00",
                DateParser.parseCalendar(task.getDateEnd()));
        }
    }
}

	// End of segment: src\tests\LogicTest.java





